<html>
<head>
<title>What is Trunk Based Development? | Git Branching Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>什么是基于主干的开发？Git分支策略</h1>
<blockquote>原文：<a href="https://www.gitkraken.com/blog/trunk-based-development#0001-01-01">https://www.gitkraken.com/blog/trunk-based-development#0001-01-01</a></blockquote><div><div class="elementor-widget-container">
			
<p>这篇文章是由一位客座作者写的。</p>



<p>当有许多软件开发人员在同一个项目上工作时，跟踪单个变更和以前的版本是至关重要的，尤其是当它有助于防止减缓开发和部署过程的冲突时。对于世界上大多数的开发团队来说，Git是组织文件和软件版本的首选系统。</p>



<p>从项目开始，您的团队应该选择一个开发策略，并确保所有团队成员在他们的工作流程中一致地应用它。选择正确的策略取决于几个因素，包括团队规模、您正在开发的软件的复杂性以及您已经在使用的其他工具。您还应该考虑您的团队更喜欢如何合作，以及单个团队成员的专业知识和经验。</p>



<p>本文将重点介绍基于主干的开发，包括好处和最佳实践，以及一些流行的<a href="https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy" target="_blank" rel="noreferrer noopener"> Git分支策略</a> : <a href="https://www.gitkraken.com/blog/gitflow" target="_blank" rel="noreferrer noopener"> Gitflow </a>，GitHub flow和GitLab flow。</p>



<p aria-hidden="true" class="wp-block-spacer"/>







<p aria-hidden="true" class="wp-block-spacer"/>



<div class="callout">
<div class="callout-content">
<p>手头拥有合适的工具是任何开发策略的关键部分。GitKraken客户端支持成功的Gitflow工作流、基于主干的开发等。<br/></p>

</div>
</div>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2 id="what-is-trunk-based-development">什么是基于主干的开发？</h2>



<p>基于主干的开发在方法上与最流行的Git分支策略明显不同。基于主干的开发不依赖于特性分支，而是让每个开发人员在本地独立地处理他们的项目，然后至少每天一次将他们的变更合并回主分支(主干)。无论功能更改或添加是否完成，合并都必须发生。</p>



<p>李雅达·斯科特在为HackerNoon撰写的一篇文章中总结了如何使用Git 进行基于<a href="https://hackernoon.com/a-guide-to-git-with-trunk-based-development-93a350c" target="_blank" rel="noreferrer noopener">主干的开发:</a></p>



<blockquote class="wp-block-quote"><p>“……我们需要以不同于您可能习惯的方式来处理事情。我们仍然希望将一些操作与提交联系起来，但不会有太多不同的概念——我们只想做与我们正在工作的代码库相关的事情。相反，我们可以将该操作限制为发布我们正在工作的项目的新版本化工件。”</p></blockquote>



<p>在另一篇文章中，本·莫里斯解释道:</p>



<blockquote class="wp-block-quote"><p>“基于主干的开发不仅仅是一种分支策略。这是一组有助于实现更高效开发的技术。</p><p>团队通过<em>抽象</em>使用<em>分支</em>来分离大规模特性的工作。抽象层隔离正在进行的工作，并允许功能的多种实现存在于同一个代码库中。尽管一个系统包含了多个不完整的特性，它仍然可以安全地从主干中释放出来。"</p></blockquote>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2 id="benefits-trunk-based-development">基于主干的开发的好处</h2>



<p>基于主干的开发策略没有传统的Git分支策略复杂，因为它们通常涉及更少的分支和更少的<a href="https://www.gitkraken.com/learn/git/tutorials/how-to-resolve-merge-conflict-in-git" target="_blank" rel="noreferrer noopener"> Git合并冲突</a>的风险。基于主干的开发也非常适合在CI/CD方法中使用，因为主干是可持续部署的。</p>



<p>定期更新为整个团队提供了项目变更状态的更大可见性。因此，团队可以更快地识别和解决潜在的合并问题。与Gitflow相比，在git flow中，合并之间可能会经过很长时间，从而增加了冲突的机会，基于主干的开发限制了冲突的风险。使用基于主干的开发，陷入合并地狱的可能性要小得多。</p>



<p>在基于主干的开发中，协作发生在主干上，而不是在单独的功能分支上。然而，团队成员必须不断合作，以防止问题影响主干。总的来说，协作水平需要很高，所有团队成员必须不断地一起朝着下一个目标努力。</p>



<p>GitKraken Client 的设计考虑到了团队协作，为您喜欢的任何工作流程提供了更少的上下文切换、更好的通信和无缝流程。</p>



<p>由于其敏捷的本质，<a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noreferrer noopener">基于主干的开发</a>在当今的容器和微服务密集型开发环境中也非常有用。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2 id="cons-trunk-based-development">基于主干的开发的缺点</h2>



<p>当然，基于主干的开发并不是没有问题。基本上，基于主干的开发比传统的Git分支策略更复杂，因此需要更高级的开发技能。</p>



<p>正如Ben Morris在他的文章<a href="https://www.ben-morris.com/why-trunk-based-development-isnt-for-everybody/" target="_blank" rel="noreferrer noopener"> <em>中解释的，为什么基于主干的开发不适合所有人</em> </a>:</p>



<blockquote class="wp-block-quote"><p>“尽管基于主干的开发可以减少合并冲突，但它不一定会减少管理并发特性开发的复杂性。从某种意义上来说，您只是将这种复杂性重新分配给了下游的其他流程，如代码设计和应用程序配置。”</p></blockquote>



<p>年轻的开发人员可能对使用基于主干的开发缺乏信心，因为变更直接进入主干，而不是像其他基于Git的策略那样需要中间阶段。这种担心是有充分理由的。由缺乏经验的开发人员注入主干的问题会导致重大的部署问题。因此，当你有经验丰富的开发人员的小团队时，基于主干的开发策略是最好的。</p>



<p>基于主干的开发也不太能跟踪个体的变化。Gitflow 是高度组织化的，对每个特性使用单独的分支，而基于主干的策略将所有的变更都转储到主分支，不管它们的状态如何。可能更容易丢失单个部件的轨迹。</p>



<p>您可以使用<a href="https://www.gitkraken.com/git-client" target="_blank" rel="noreferrer noopener"> GitKraken Client </a>提升团队的Git体验，这是一款让初级开发人员和专家都能提高生产力的工具，包括<a href="https://www.gitkraken.com/learn/git" target="_blank" rel="noreferrer noopener"> Learn Git </a>资源将帮助初学者快速增长知识。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2 id="best-practices">基于主干的开发最佳实践</h2>



<p>如前所述，拥有高级开发技能的小型团队在基于主干的开发策略中会有更好的成功机会。</p>



<p>您还需要确保您有一个可以支持特性抽象的代码库，并且您准备好了特性标志的解决方案。</p>



<p>最后，投资于一个持续的构建和测试基础设施，以及能够适应高提交率的审查和发布的简化流程。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2 id="git-branching-strategies">流行的Git分支策略</h2>



<p>与基于主干的开发相比，以下Git分支策略是使应用程序拥有多个并行开发路径更简单、更不容易出错的工作流。Git中更直接的分支策略可以帮助个体开发人员了解如何将他们的更改集成到代码的主要生产版本中。</p>



<p>精心选择的Git分支策略为开发团队提供了许多潜在的好处，包括:</p>



<ul><li>简化并行开发</li><li>促进高效的团队协作</li><li>为将变更集成到生产代码中提供清晰的开发工作流</li><li>最小化Git合并冲突</li><li>限制在产品代码中引入错误</li><li>为新版本提供简化的路线图</li></ul>



<p aria-hidden="true" class="wp-block-spacer"/>



<p>最流行的<a href="https://www.gitkraken.com/learn/git/branch" target="_blank" rel="noreferrer noopener"> Git分支</a>策略包括:Gitflow、GitHub flow、GitLab flow。</p>



<p aria-hidden="true" class="wp-block-spacer">Gitflow</p>



<h2>Gitflow一直是使用Git 的<a href="https://www.gitkraken.com/git-client/team-features" target="_blank" rel="noreferrer noopener">团队最流行的分支策略之一。该策略总共使用了五种不同的分支类型:两种主要分支——<em>主要分支</em>和<em>开发分支</em>——以及三种特殊用途分支，如<em>功能</em>、<em>发布</em>和<em>热修复</em>。Gitflow中的主分支使用标签来标识具体的生产版本(如下图所示的0.1、0.2、1.0)。开发分支是从标记的主分支版本中克隆出来的。</a></h2>



<p>使用Gitflow，许多开发人员可以并行工作，在发布新的候选功能之前在功能分支内协作。因为Gitflow使用一个单独的沙盒暂存区来发布，它可以帮助开发团队确保只有经过验证的功能才能投入生产。独立的发布分支也允许团队轻松地将<a href="https://www.atlantic.net/hipaa-compliant-hosting/post-pandemic-top-cybersecurity-threats-to-healthcare-security/" target="_blank" rel="noreferrer noopener">设计安全原则</a>集成到开发过程中。</p>



<p>特殊目的分支是从开发分支创建的，并且多个特殊目的分支可以同时存在。虽然主分支和开发分支是永久性的，但是特性分支通常只在完成特定任务所需的时间内存在，这可能是几天、几周甚至几个月。</p>



<p>团队在功能分支中直接合作。当他们完成一个特性的开发时，他们将它合并回开发分支。合并新功能没有固定的时间表——根据需要进行合并。</p>



<p>除了功能分支之外，开发人员还可以使用热修复分支来快速解决生产代码中的问题。与功能分支不同，修补程序分支是从主分支延伸出来的。然而，开发人员必须记住将完成的修补程序合并到主分支和开发分支中。</p>



<p>开发团队可以从开发分支中克隆一个发布分支。发布分支充当新发布候选的测试和QA沙箱。与热修复分支一样，发布分支中的最终修改必须合并到主分支和开发分支中。</p>



<p>Gitflow的创建者Vincent Dreissen创建了一个有用的<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noreferrer noopener">摘要概览图</a>，展示了Gitflow的各个分支以及它们之间的关系:</p>



<p>Gitflow的创建者Vincent Dreissen创建了一个有用的<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noreferrer noopener">摘要概览图</a>，展示了Gitflow的各个分支以及它们之间的关系:</p>



<p aria-hidden="true" class="wp-block-spacer"/>


<div class="wp-block-image">
<figure class="aligncenter size-large is-resized"><picture decoding="async" class="wp-image-8367">
<source type="image/webp" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-773x1024.png.webp 773w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-1160x1536.png.webp 1160w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow.png.webp 1184w" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20773%201024'%3E%3C/svg%3E" data-lazy-sizes="(max-width: 773px) 100vw, 773px"/>
<img decoding="async" src="" alt="Gitflow diagram by Vincent Drissen" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-773x1024.png 773w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-227x300.png 227w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-768x1017.png 768w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-1160x1536.png 1160w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow.png 1184w" data-lazy-sizes="(max-width: 773px) 100vw, 773px" data-lazy-src="https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-773x1024.png"/>
</picture>
<noscript><picture decoding="async" class="wp-image-8367">
<source type="image/webp" srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-773x1024.png.webp 773w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-1160x1536.png.webp 1160w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow.png.webp 1184w" sizes="(max-width: 773px) 100vw, 773px"/>
<img decoding="async" src="../Images/a2fa9156a170f9da0d15f2f44c569ea9.png" alt="Gitflow diagram by Vincent Drissen" srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-773x1024.png 773w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-227x300.png 227w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-768x1017.png 768w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-1160x1536.png 1160w, https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow.png 1184w" sizes="(max-width: 773px) 100vw, 773px" data-original-src="https://www.gitkraken.com/wp-content/uploads/2022/07/trunk-based-development-vs-gitflow-773x1024.png"/>
</picture>
</noscript><figcaption>From <em>A successful Git branching model</em> by Vincent Driessen</figcaption></figure></div>


<p aria-hidden="true" class="wp-block-spacer">在GitKraken客户端中设置Gitflow工作流程需要3个步骤。看⬇️对自己来说有多容易<br/></p>



<div class="callout">
<div class="callout-content">
<p>在GitKraken客户端中设置Gitflow工作流程需要3个步骤。看⬇️对自己来说有多容易<br/></p>

</div>
</div>



<p aria-hidden="true" class="wp-block-spacer">Gitflow与基于主干的开发</p>



<h2 id="gitflow-vs-trunk-based-development">凭借其高度组织、良好定义和良好分离的结构，Gitflow可以很容易地了解项目在任何给定时间发生了什么。然而，众多分支的增加增加了合并冲突的风险。而且团队越大，将问题引入主代码库的风险就越大。</h2>



<p>因为Gitflow策略要求开发人员在代码投入生产之前执行许多不同的提交，所以项目历史可能变得难以分析。通过复杂的分支和提交网络跟踪错误可能会非常耗时且令人沮丧。事实上，即使Gitflow旨在加速开发，如果单个开发人员缺乏对如何在他们的工作流程中正确实施策略的理解，成功将是不太可能的。</p>



<p>如果你的团队确实需要对他们的项目历史有更多的了解，一个健壮但易于使用的Git GUI(如GitKraken Client)可以为每个技能水平的开发人员带来巨大的不同。在GitKraken客户端中设置<a href="https://help.gitkraken.com/gitkraken-client/git-flow/" target="_blank" rel="noreferrer noopener"> Gitflow非常简单直观，只需要3个步骤。</a></p>



<p>如果你的团队确实需要对他们的项目历史有更多的了解，一个健壮但易于使用的Git GUI(如GitKraken Client)可以为每个技能水平的开发人员带来巨大的不同。在GitKraken客户端中设置<a href="https://help.gitkraken.com/gitkraken-client/git-flow/" target="_blank" rel="noreferrer noopener"> Gitflow非常简单直观，只需要3个步骤。</a></p>



<p aria-hidden="true" class="wp-block-spacer"/>


<div class="wp-block-image">
<figure class="aligncenter size-large"><picture decoding="async" class="wp-image-8375">
<source type="image/webp" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1024x689.png.webp 1024w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1536x1034.png.webp 1536w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client.png.webp 1640w" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20689'%3E%3C/svg%3E" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" src="" alt="Gitflow settings in GitKraken Client" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1024x689.png 1024w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-300x202.png 300w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-768x517.png 768w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1536x1034.png 1536w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client.png 1640w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1024x689.png"/>
</picture>
<noscript><picture decoding="async" class="wp-image-8375">
<source type="image/webp" srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1024x689.png.webp 1024w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1536x1034.png.webp 1536w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client.png.webp 1640w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" src="../Images/fddd5f17a425c16d2774a38bf6bd7eb9.png" alt="Gitflow settings in GitKraken Client" srcset="https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1024x689.png 1024w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-300x202.png 300w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-768x517.png 768w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1536x1034.png 1536w, https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client.png 1640w" sizes="(max-width: 1024px) 100vw, 1024px" data-original-src="https://www.gitkraken.com/wp-content/uploads/2022/07/gitflow-vs-trunk-based-development-gitkraken-client-1024x689.png"/>
</picture>
</noscript><figcaption><em>Setting up Gitflow preferences in GitKraken Client</em></figcaption></figure></div>


<p aria-hidden="true" class="wp-block-spacer">当团队想要实现<a href="https://www.gitkraken.com/blog/what-is-continuous-integration" target="_blank" rel="noreferrer noopener">持续集成</a>/持续交付(CI/CD)工作流时，Gitflow的复杂性质和缺乏对主分支提交的定义时间也使得它不适合。就其本质而言，持续集成是基于对主分支的代码变更的定期合并。另一方面，如果您的项目允许较长的部署间隔，那么Gitflow可能是一个很好的选择。</p>



<p>同样，连续交付需要立即投入生产的能力。然而，在Gitflow中，开发人员必须创建一个发布分支，将其合并到主分支和开发分支中，并在变更进入生产之前在主分支中标记新的生产版本。Gitflow实际上更鼓励不连续的交付过程，而不是连续的。</p>



<p>GitHub流</p>



<p aria-hidden="true" class="wp-block-spacer">GitHub flow是Gitflow的简化版本，取消了开发和发布分支。相反，特性分支直接来自于主分支。</p>



<h2>使用这种策略，开发人员将变更提交到特性分支，并在那里测试它们。只有在做出go决策后，开发人员才会将功能分支合并到主分支中。</h2>



<p>因为<a href="https://www.gitkraken.com/integrations/github" target="_blank" rel="noreferrer noopener"> GitHub </a> flow缺少Gitflow的中间分支，历史更容易跟随。与Gitflow不同，GitHub flow可以轻松集成到CI/CD管道中。</p>



<p>GitHub流的一个缺点是，在将功能更改合并到主分支之前，如果没有充分测试这些功能更改，可能会导致错误和不稳定的产品版本。</p>



<p>因为它是轻量级的，并且比其他Git分支策略更快，所以GitHub flow对于应用敏捷开发原则的小型团队来说非常有效。然而，随着团队规模的增加，GitHub flow失去了其有益的品质。</p>



<p>GitLab Flow</p>



<p>Gitflow的另一个简化版本，<a href="https://www.gitkraken.com/integrations/gitlab" target="_blank" rel="noreferrer noopener"> GitLab </a> flow在将变更合并回主分支并投入生产之前，使用预生产分支来测试变更。GitLab flow专注于问题跟踪，当新特性被合并到主分支时，构建有用的历史。和GitHub流一样，GitLab流在使用CI/CD时更可行。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2>基于主干的开发适合你吗？</h2>



<p>基于主干的开发和其他分支策略都有它们擅长和落后的地方。幸运的是，如果您的需求或环境在项目过程中发生了变化，可以从一种策略切换到另一种策略。</p>



<p aria-hidden="true" class="wp-block-spacer">在整个软件开发生命周期中跟踪变更和版本是一项至关重要但并不简单的任务。最终，基于主干的开发和流行的Git分支策略应该为开发人员提供确保健壮、稳定的产品版本所需的工具，同时允许他们根据需要频繁地部署变更。</p>



<h2>与大多数工具一样，没有“一刀切”的解决方案考虑您的开发团队的组成和每个特定项目的需求，以决定哪条道路适合您。如果你一开始没有成功，那就换一种方法。真的就这么简单。</h2>



<p>基于主干的开发和其他分支策略都有它们擅长和落后的地方。幸运的是，如果您的需求或环境在项目过程中发生了变化，可以从一种策略切换到另一种策略。</p>



<p>无论您选择哪种策略，拥有帮助您可视化和理解代码库的工具将有助于您的团队成功和扩展。br &gt;</p>



<p>与大多数工具一样，没有“一刀切”的解决方案考虑您的开发团队的组成和每个特定项目的需求，以决定哪条道路适合您。如果你一开始没有成功，那就换一种方法。真的就这么简单。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<div class="callout">
<div class="callout-content">
<p>无论您选择哪种策略，拥有帮助您可视化和理解代码库的工具将有助于您的团队成功和扩展。br &gt;</p>

</div>
</div>
		</div>
				</div>    
</body>
</html>