<html>
<head>
<title>Shell Scripting | Intro to the CLI Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Shell脚本CLI简介第5部分</h1>
<blockquote>原文：<a href="https://www.gitkraken.com/blog/shell-scripting#0001-01-01">https://www.gitkraken.com/blog/shell-scripting#0001-01-01</a></blockquote><div><div class="elementor-widget-container">
			
<p>在CLI介绍系列的前几篇文章中，我们已经讨论了为什么要掌握使用命令行、一些命令行基础知识和工具，以及定制CLI shell的技巧。如果您错过了任何内容，请随时使用以下链接进行补充:</p>



<p><a href="https://www.gitkraken.com/blog/cli-stands-for-a-cli-intro-series" target="_blank" rel="noreferrer noopener">第1部分:CLI <br/> </a> <a href="https://www.gitkraken.com/blog/shell-commands" target="_blank" rel="noreferrer noopener">的作用和原因第2部分:Shell命令介绍<br/> </a> <a href="https://www.gitkraken.com/blog/command-line-tools" target="_blank" rel="noreferrer noopener">第3部分:命令行工具<br/> </a> <a href="https://www.gitkraken.com/blog/cli-shell" target="_blank" rel="noreferrer noopener">第4部分:定制您的CLI Shell </a></p>



<p aria-hidden="true" class="wp-block-spacer"/>



<p>现在，您将学习shell脚本的基础知识，以自动化复杂的工作并构建全新的应用程序！</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<div class="callout">
<div class="callout-content">
<p>如果您足够高级，能够编写shell脚本，您可能不认为您需要Git客户机。虽然这可能是真的，但有了它，生活会变得更好，尤其是有内置终端的手机。🤯<br/></p>

</div>
</div>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2>Shell脚本–自动化和构建新应用</h2>



<p>当你看一部电影或一个流媒体系列时，你真正看到的是一个演员和工作人员在执行一个剧本。该脚本从上到下从左到右阅读，直到他们到达结尾。类似地，计算机已经变得非常擅长阅读脚本并完全按照它们说的去做。<br/> <br/>这些脚本可以很长，做的事情比如通过管理Docker提供本地开发环境，就像<a href="https://docksal.io/" target="_blank" rel="noreferrer noopener"> Docksal </a>的情况一样，这些脚本也可以很简单，比如“<a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program" target="_blank" rel="noreferrer noopener"> hello world </a>”。</p>



<p>在本文中，我们将讨论一些与shell脚本相关的主题以及一些您可以运行的特定shell脚本。</p>







<p aria-hidden="true" class="wp-block-spacer">Hello World脚本</p>



<h2 id="hello-world-script">要编写一个hello world脚本，完成以下步骤:<br/> <br/> 1 .在文本编辑器中打开一个名为<code>hello-world.sh</code>的新文件。</h2>



<p>2.在新文件中键入以下内容:</p>



<p><code>``</code></p>



<p><code>#!/bin/bash<br/># This script prints Hello World to the screen<br/>echo "Hello World"</code></p>



<p><code>``</code></p>



<p>3.保存文件。<br/> <br/> 4。在与<code>hello-world.sh</code>相同的目录中，从终端运行以下命令:</p>



<p><code>$ chmod 755 hello-world.sh:</code></p>



<p>5.接下来，运行命令:<br/> <br/> <code>$ ./hello-world.sh</code></p>



<p>6.你现在应该看到<code>Hello World</code>打印在屏幕上。</p>



<p>6.你现在应该看到<code>Hello World</code>打印在屏幕上。</p>



<p aria-hidden="true" class="wp-block-spacer"/>





<p aria-hidden="true" class="wp-block-spacer">恭喜你！您刚刚从头开始编写并执行了您的第一个shell脚本！这是成为一名经验丰富的开发人员的一大步！</p>



<p>尽管hello world脚本很简单，但这里有很多东西需要解开。真正令人惊讶的消息是，所有的shell脚本本质上都以相同的方式工作，因此理解<code>hello-world.sh</code>和CLI shell基础意味着您将能够阅读几乎任何脚本。</p>



<p>尽管hello world脚本很简单，但这里有很多东西需要解开。真正令人惊讶的消息是，所有的shell脚本本质上都以相同的方式工作，因此理解<code>hello-world.sh</code>和CLI shell基础意味着您将能够阅读几乎任何脚本。</p>



<p aria-hidden="true" class="wp-block-spacer">用Shebang调用Shell解释器</p>



<h3>让我们从<code>hello-world.sh</code> : <br/> <br/> <code>#!/bin/bash</code> <br/> <br/>的第一行开始，那第一部分，<code>#!</code>被称为<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)" target="_blank" rel="noreferrer noopener">射棒</a>。shebang告诉操作系统接下来应该调用的程序是读取和执行文件的其余内容。这个程序被称为脚本解释器。在这种情况下，它调用位于<code>/bin</code>文件夹中的<code>bash</code>。<code>bin</code>代表二进制。</h3>



<p>你的<code>/bin</code>文件夹里有很多文件。您可以通过运行以下命令来查看计算机上该文件夹的所有内容:</p>



<p><code>$ ls /bin</code></p>



<p>在您的<code>/bin</code>文件夹中，除了<code>bash</code>和<code>zsh</code>之外，您可能还会识别出一些您的操作系统可以执行的文件，比如<code>date</code>、<code>cp</code>、<code>ls</code>和<code>mv</code>等等。这是这些命令的可执行二进制文件在系统中的位置。<br/> <br/>当您运行以<code>#!/bin/bash</code>开头的shell脚本时，您实际上是在告诉计算机打开一个非交互式、非登录的shell来运行文件中的命令。</p>



<p aria-hidden="true" class="wp-block-spacer">即使它是非交互式的，计算机仍然可以访问您执行shell脚本的终端，并且能够接受输入和打印运行它的会话的输出。这可能有点令人困惑，所以如果你想深入了解，这里有一个关于非交互式shell和shell脚本的更加详细的解释。出于本文的目的，我们需要知道的是，在第一行之后，一切都只是CLI shell命令和一些Bash脚本语法。</p>





<p aria-hidden="true" class="wp-block-spacer">Bash脚本与Zsh脚本</p>



<p>您可能会问自己，为什么对shell使用Zsh，对shell脚本语言使用Bash。非常简单的答案是，Bash更像是一个脚本工具，所以编写Bash脚本意味着您的代码将在更多的机器上工作。<br/> <br/>无论你是在Fedora、Ubuntu、macOS、FreeBSD还是任何其他*NIX操作系统上，hello world脚本都会以同样的方式运行。您可以放心地在几乎任何*nix服务器或您可以访问的远程系统上使用Bash脚本。这是一种将命令行工具捆绑在一起的通用语言。Zsh是一个令人惊叹的交互式CLI shell，但它并没有被普遍采用。</p>



<p>即使它是非交互式的，计算机仍然可以访问您执行shell脚本的终端，并且能够接受输入和打印运行它的会话的输出。这可能有点令人困惑，所以如果你想深入了解，这里有一个关于非交互式shell和shell脚本的更加详细的解释。出于本文的目的，我们需要知道的是，在第一行之后，一切都只是CLI shell命令和一些Bash脚本语法。</p>



<p aria-hidden="true" class="wp-block-spacer">GitKraken客户端配备了GUI和CLI，为所有操作系统的高级开发人员提供了最佳体验。⬇️自己试试<br/></p>



<h2 id="bash-script-vs-zsh-script">其他Shell脚本选项</h2>



<p>如果您已经精通另一种语言，如Perl、Python、Ruby，甚至PHP，您完全可以使用它们来解释和运行您的shell脚本。您可以自由地告诉您的计算机使用任何已安装的程序来尝试评估文件的内容。<br/> <br/>举个例子，用Python3评估一个文件，你需要做的就是在你的Python脚本顶端加上这一行:<br/> <br/> <code>#!/usr/bin/python3</code></p>



<p aria-hidden="true" class="wp-block-spacer"/>



<div class="callout">
<div class="callout-content">
<p>你的hello world脚本的第二行是:</p>

</div>
</div>



<p aria-hidden="true" class="wp-block-spacer"><code># This script prints Hello World to the screen</code> <br/> <br/>在Bash脚本中，<code>#</code>字符表示同一行中该符号之后的所有内容都是shell脚本注释，在执行脚本时应该忽略。您会注意到，当您运行<code>hello-world.sh</code>时，shell脚本注释不会打印到屏幕上。</p>



<h2>代码中添加的Shell脚本注释被称为<em>行内注释</em>。它们对于解释一段代码是如何工作的或者预期的结果是什么非常有帮助。Shell脚本注释是一种方便的方式，可以向以后将处理相同代码的任何其他开发人员解释您的工作。</h2>



<p>外壳脚本回显</p>



<p aria-hidden="true" class="wp-block-spacer">hello world脚本的第三行也是最后一行是:<br/><br/><code>echo "Hello World"</code><br/><br/>shell脚本echo告诉计算机将随后出现的内容打印到标准输出，默认情况下是终端屏幕。echo命令也可以在shell脚本之外工作。如果您现在尝试将该行脚本作为命令粘贴到您的终端中，您应该会看到:</p>







<p>重定向外壳输出</p>



<p>默认情况下，命令执行的输出会打印到终端屏幕上。这就是“标准输出”。在CLI系列介绍的第3部分<a href="https://www.gitkraken.com/blog/command-line-tools" target="_blank" rel="noreferrer noopener">中，我们回顾了重定向相同的输出，特别是在使用管道操作符<code>|</code>时。</a></p>



<p>例如，如果您运行<code>$ ls -a | grep .git</code>，那么<code>ls -a</code>命令的输出将被传送到<code>grep</code>的输入中，并且只搜索该输入或匹配模式<code>.git</code>。</p>



<p aria-hidden="true" class="wp-block-spacer">外壳脚本回显</p>



<h2 id="shell-script-echo">重定向输出的另一种方法是使用重定向操作符<code>&gt;</code>和<code>&gt;&gt;</code>。这些运算符最常用于将命令的输出传输到文件中。<br/>T5<code>&gt;</code>覆盖任何文件内容。例如，如果您运行:<br/><br/><code>$ echo "Hello" &gt; hello.txt</code><br/><br/>…您将得到一个新文件，其中只有“Hello”一行。</h2>



<p>然后，如果您要运行以下命令:</p>



<p aria-hidden="true" class="wp-block-spacer"><code>$ echo "World" &gt; hello.txt</code></p>





<p aria-hidden="true" class="wp-block-spacer">….该文件将包含单行“World ”,覆盖了该文件以前的内容。小心这个操作员！</p>



<h3>默认情况下，命令执行的输出会打印到终端屏幕上。这就是“标准输出”。在CLI系列介绍的第3部分<a href="https://www.gitkraken.com/blog/command-line-tools" target="_blank" rel="noreferrer noopener">中，我们回顾了重定向相同的输出，特别是在使用管道操作符<code>|</code>时。</a></h3>



<p>例如，如果您运行<code>$ ls -a | grep .git</code>，那么<code>ls -a</code>命令的输出将被传送到<code>grep</code>的输入中，并且只搜索该输入或匹配模式<code>.git</code>。</p>



<p><code>&gt;&gt;</code>操作符将命令的输出附加到现有内容下的文件中。以<br/> <br/>为例，继续上一个例子，如果你要运行:<br/> <br/> <code>$ echo 'Hello World' &gt;&gt; hello.txt</code></p>



<p aria-hidden="true" class="wp-block-spacer">…当您查看内容时，应该会看到两行:第一行是“World”，第二行是“Hello World”。</p>



<figure class="wp-block-image aligncenter size-full"><picture decoding="async" class="wp-image-8607">
<source type="image/webp" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting.png.webp 946w" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20946%20142'%3E%3C/svg%3E" data-lazy-sizes="(max-width: 946px) 100vw, 946px"/>
<img decoding="async" src="" alt="Running ls -a | grep .git and showing .git and .gitignore as a result." data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting.png 946w, https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting-300x45.png 300w, https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting-768x115.png 768w" data-lazy-sizes="(max-width: 946px) 100vw, 946px" data-lazy-src="https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting.png"/>
</picture>
<noscript><picture decoding="async" class="wp-image-8607">
<source type="image/webp" srcset="https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting.png.webp 946w" sizes="(max-width: 946px) 100vw, 946px"/>
<img decoding="async" src="../Images/eca14d6dc46defb401c3801e1d9fe29d.png" alt="Running ls -a | grep .git and showing .git and .gitignore as a result." srcset="https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting.png 946w, https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting-300x45.png 300w, https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting-768x115.png 768w" sizes="(max-width: 946px) 100vw, 946px" data-original-src="https://www.gitkraken.com/wp-content/uploads/2022/08/grep-git-shell-scripting.png"/>
</picture>
</noscript></figure>



<p aria-hidden="true" class="wp-block-spacer">重定向输出的另一种方法是使用重定向操作符<code>&gt;</code>和<code>&gt;&gt;</code>。这些运算符最常用于将命令的输出传输到文件中。<br/>T5<code>&gt;</code>覆盖任何文件内容。例如，如果您运行:<br/><br/><code>$ echo "Hello" &gt; hello.txt</code><br/><br/>…您将得到一个新文件，其中只有“Hello”一行。</p>



<p>然后，如果您要运行以下命令:</p>



<p>重定向操作符的一个非常常见的用途是为应用程序创建和更新日志文件。当您开始调试自己的应用程序时，特别是当它们的规模和复杂性增加时，将脚本输出重定向到一个您可以搜索和查看的文件中是非常有帮助的。</p>



<p>sh文件扩展名</p>



<p>既然您已经查看了hello world脚本示例的内部，那么让我们后退一步，查看文件本身以及它是如何执行的。</p>



<p aria-hidden="true" class="wp-block-spacer">文件扩展名<code>.sh</code>代表“shell脚本”,实际上只是为了便于阅读。对于shell来说，sh文件扩展名只是一个文本文件。因为操作系统从第一行开始读取以确定如何解释文件内容，所以文件的实际名称对机器来说并不重要，但是当您使用文件扩展名时，将文件的性质传达给其他开发人员甚至您自己会容易得多。</p>





<p aria-hidden="true" class="wp-block-spacer">让我们通过将<code>hello-world.sh</code>重命名为<code>hello-world</code>来快速测试一下，并尝试以与之前相同的方式再次运行它。</p>



<p>…当您查看内容时，应该会看到两行:第一行是“World”，第二行是“Hello World”。</p>



<p>…when you look at the contents, you should see two lines: the first being “World”, and the second being “Hello World”.</p>



<p aria-hidden="true" class="wp-block-spacer">运行外壳脚本的权限</p>





<p aria-hidden="true" class="wp-block-spacer">创建并保存<code>hello-world.sh</code>后的下一步是运行这个看起来很奇怪的命令:</p>



<p><code>chmod 755 hello-world.sh</code></p>



<p aria-hidden="true" class="wp-block-spacer">sh文件扩展名</p>



<h2 id="sh-file-extension">了解Shell中的文件系统权限</h2>



<p>文件系统中的每个文件都有权限设置，也称为模式，允许三类不同的潜在用户读取、写入或执行文件。潜在用户的类别有:<br/></p>



<p>1.用户-文件所有者<br/> 2。group–一组指定的用户，他们在机器<br/> 3上共享相同的文件权限。其他——上述两个类别之外的任何人</p>



<p>1.用户-文件所有者<br/> 2。group–一组指定的用户，他们在机器<br/> 3上共享相同的文件权限。其他——上述两个类别之外的任何人</p>



<p aria-hidden="true" class="wp-block-spacer"><code>ls</code>命令允许您查看文件和目录的详细信息。<code>ls -l</code>实际上向我们展示了谁拥有什么权限。</p>





<p aria-hidden="true" class="wp-block-spacer">运行外壳脚本的权限</p>



<h2>创建并保存<code>hello-world.sh</code>后的下一步是运行这个看起来很奇怪的命令:</h2>



<p>与hello world脚本相关联的行是:</p>



<p><code>-rwxr-xr-x  1 dwaynemcdaniel  staff   79 Feb  4 09:46 hello-world</code> <br/> <br/>让我们快速分解一下上面所说的内容。<br/> <br/>第一列:<code>-rwxr-xr-x</code>说明你的文件权限。第一个字符告诉你这是一个文件<code>-</code>还是一个目录<code>d</code>。<br/> <br/>接下来的三个字符:<code>rwx</code>告诉你文件所有者可以读、写、执行文件。<br/> <br/>中间三个字符:<code>r-x</code>表示一个组中指定的任意用户的权限。在这种情况下，组中的任何人都可以读取或执行该文件，但不能写入。组起源于Unix系统，它涉及所有用户共享同一个物理机器。</p>



<p aria-hidden="true" class="wp-block-spacer">第一列中的最后三个字符:<code>r-x</code>表示任何其他用户或代理的权限，比如Bash同样，在这种情况下，他们可以读取或执行文件，但不能写入文件。这一行的其余部分告诉您:</p>



<h4>–第2列:从系统的其他地方到该文件有多少个链接<br/>–第3列:文件所有者的名称<br/>–第4列:哪个组拥有该文件<br/>–第5列:以<a href="https://simple.wikipedia.org/wiki/Byte" target="_blank" rel="noreferrer noopener">字节</a>为单位的文件大小<br/>–第6列:文件的最后修改日期<br/>–第7列:文件或目录名</h4>



<p>1.用户-文件所有者<br/> 2。group–一组指定的用户，他们在机器<br/> 3上共享相同的文件权限。其他——上述两个类别之外的任何人</p>



<p>更改文件访问以运行Shell脚本</p>



<p aria-hidden="true" class="wp-block-spacer"><code>chmod</code>让我们重新分配每个文件夹或目录的权限，影响读取、写入或执行(可能时)文件或文件夹的能力。</p>



<p>运行<code>hello-world.sh</code>的指令中使用的<code>755</code>告诉计算机为用户、组和其他人设置权限，遵循一个非常简洁的数学符号。<br/> <br/>可能的文件权限有:</p>



<p aria-hidden="true" class="wp-block-spacer">–0 =无权限<br/>–1 =仅执行<br/>–2 =仅写入<br/>–3 =写入并执行(1+2 = 3)<br/>–4 =只读<br/>–5 =读取并执行(1+4 = 5)<br/>–6 =读取并写入(2+4 = 6)<br/>–7 =读取并执行(1 + 2 + 4 = 7)</p>





<p aria-hidden="true" class="wp-block-spacer">与hello world脚本相关联的行是:</p>



<p><a href="https://en.wikipedia.org/wiki/Chmod" target="_blank" rel="noreferrer noopener">用<code>chmod</code> </a>设置文件访问模式还有其他多种方式，但是编号系统容易记忆，非常方便。<code>755</code>通常被认为是本地运行的安全选择，因为它为Bash和任何其他用户提供了一种读取和执行shell脚本的方法，而无需修改它正在读取的文件。</p>



<p>第一列中的最后三个字符:<code>r-x</code>表示任何其他用户或代理的权限，比如Bash同样，在这种情况下，他们可以读取或执行文件，但不能写入文件。这一行的其余部分告诉您:</p>



<p>评估文件以运行Shell脚本</p>



<p>运行<code>$ ./hello-world.sh</code>实际上是执行shell脚本。第一部分:<code>./</code>，告诉操作系统评估路径末尾的文件。</p>



<p aria-hidden="true" class="wp-block-spacer"><code>.</code>指的是shell当前工作的目录。当操作系统评估一个文件时，它读取第一行并寻找shebang，<code>#!</code>，以便打开一个新的非交互式shell来执行它在下面指定路径的末尾找到的任何命令。在这种情况下，<code>/bin/bash</code>，这一点我们已经在上面介绍过了。</p>



<h2>你可能想知道为什么不能像调用其他命令如<code>ls</code>、<code>mv</code>或<code>bash</code>一样直接调用命令<code>hello-world.sh</code>。嗯，您可以通过将您的shell脚本添加到<code>$PATH</code>的一个文件夹中来实现这一点。</h2>



<p>路径环境变量</p>



<p>path环境变量或<code>$PATH</code>很重要，因为shell使用它来跟踪包含可执行文件的目录列表。当您键入类似于<code>ls</code>的命令时，shell会在<code>$PATH</code>中列出的默认文件夹列表中进行搜索，直到找到一个名为<code>ls</code>的可执行文件，然后执行该文件。这是您的CLI shell运行所有命令的方式，除了您告诉它特别评估的文件，就像您对脚本示例所做的那样。</p>



<p>要查看当前存储在您计算机上的<code>$PATH</code>中的内容，您可以运行以下命令:</p>



<p aria-hidden="true" class="wp-block-spacer"><code>echo $PATH</code></p>



<p>如果您使用的是macOS，默认情况下，您的路径可能会是这样的:</p>



<p aria-hidden="true" class="wp-block-spacer"><code>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</code></p>



<h2>$PATH存储为冒号分隔的列表，这意味着每个条目由一个<code>:</code>分隔。这些是操作系统检查的默认目录:</h2>



<p>–/usr/local/bin<br/>–/usr/bin<br/>–/bin<br/>–/usr/sbin<br/>–/sbin</p>



<p>你可能想知道为什么不能像调用其他命令如<code>ls</code>、<code>mv</code>或<code>bash</code>一样直接调用命令<code>hello-world.sh</code>。嗯，您可以通过将您的shell脚本添加到<code>$PATH</code>的一个文件夹中来实现这一点。</p>



<p>花点时间看看每个文件夹里都有什么。了解哪些命令是可用的总是一个好主意，即使您不经常运行一些命令。</p>



<p aria-hidden="true" class="wp-block-spacer">路径环境变量</p>



<h2 id="path-environment-variable">终端的环境变量</h2>



<p>我们刚刚讨论了path环境变量(或<code>$PATH</code>)。作为一个环境变量意味着shell脚本存储了一个值，该值可以被整个操作系统环境中的任何进程访问。</p>



<p><code>$Path</code>只是众多环境变量中的一个。例如，另一个是<code>$HOME</code>，尽管在本系列中我们通过它的自动特殊别名(代字号<code>~</code>)来介绍它，作为导航文件系统的一部分。<br/> <br/>如果你在你的CLI shell中运行<code>$ echo $HOME</code>，你会看到它指向什么目录。最好不要修改<code>$HOME</code>。另一方面，T5经常被修改。<br/> <br/>要向<code>$PATH</code>添加一个新目录，您需要向您的<code>.zshrc</code>文件夹中添加一行，如下所示:<br/> <br/> <code>export PATH=path/to/directory:$PATH</code></p>



<p><code>export</code>命令使环境变量对外壳和外壳产生的任何进程可用。该命令的其余部分将<code>$PATH</code>设置为您新指定的目录加上$PATH的现有内容。</p>



<p>您安装的一些程序会让您添加一行代码，将路径导出到您的<code>.zshrc</code>，这又会在每次加载shell时更新<code>$PATH</code>。例如，像PHP、Python3、Mamp、NodeJS和npm这样的工具会自动添加或者要求您添加特定的行到您的<code>.zshrc</code>文件中，作为它们安装过程的一部分。</p>



<p>$PATH存储为冒号分隔的列表，这意味着每个条目由一个<code>:</code>分隔。这些是操作系统检查的默认目录:</p>



<p>从文件系统中的任何地方运行Shell脚本</p>



<p>为了将<code>hello-world.sh</code>作为命令执行，无论你的PWD是什么，你有三种选择:</p>



<p aria-hidden="true" class="wp-block-spacer">1.将文件的目录添加到<code>$PATH</code> <br/> 2。将文件移动到已经在<code>$PATH</code> <br/> 3中的系统目录中。结合其他选项，新建一个文件夹，把可执行文件移到那里，添加到<code>$PATH</code></p>



<p>1.将文件的目录添加到<code>$PATH</code> <br/> 2。将文件移动到已经在<code>$PATH</code> <br/> 3中的系统目录中。结合其他选项，新建一个文件夹，把可执行文件移到那里，添加到<code>$PATH</code></p>



<p aria-hidden="true" class="wp-block-spacer">所有这三种方法产生了相同的最终结果:你将能够从任何地方调用<code>hello-world.sh</code>。</p>



<h2 id="environment-variables">因为经常重用一个shell脚本将需要处理<code>$PATH</code>，所以许多开发人员选择在这一点上放弃<code>.sh</code>，就像我们在前面的例子中所做的那样。</h2>



<p>以下是将脚本重命名为<code>hello-world</code>后，任何选项的结果:</p>



<p>外壳脚本逻辑</p>



<p>现在，您已经创建了一个简单的shell脚本，更改了权限，并执行了shell脚本。下一步是理解如何向脚本添加编程逻辑。简单的shell脚本只是执行一个又一个命令，并在完成后停止。然而，一个好的CLI shell脚本的真正威力来自于这样一个事实，即您可以添加逻辑，以便只在某些情况下多次运行命令，甚至等待用户输入继续运行。</p>



<p>虽然这不是一个详尽的列表，也不意味着是一个完整的教程，但让我们快速介绍一些最常见和最有用的脚本逻辑操作。</p>



<p aria-hidden="true" class="wp-block-spacer">从文件系统中的任何地方运行Shell脚本</p>



<h2>用一个工具来执行命令，这个工具为常见的动作提供了自动建议和自动完成…这才是逻辑。<br/></h2>



<p>外壳脚本变量</p>



<p>要创建一个变量(即保存赋值的已定义实体)，只需将其声明为等于一个值:</p>



<p aria-hidden="true" class="wp-block-spacer"><code>VARIABLE1=1</code></p>



<p>要在shell脚本中使用一个变量，您需要在前面添加一个<code>$</code>来标记它为一个在命令执行中读取的变量。</p>



<p><code>echo $VARIABLE1</code></p>



<p>虽然不是必需的，但是shell脚本变量的一个常见的最佳实践是用大写字母命名它们。一些开发人员认为这使得阅读脚本和理解正在发生的事情变得更加容易。</p>



<p aria-hidden="true" class="wp-block-spacer">虽然不是必需的，但是shell脚本变量的一个常见的最佳实践是用大写字母命名它们。一些开发人员认为这使得阅读脚本和理解正在发生的事情变得更加容易。</p>





<p aria-hidden="true" class="wp-block-spacer">Shell脚本中的If Else语句</p>



<h2 id="shell-script-logic">shell脚本中的if/else语句使用以下过程:</h2>



<p>测试一个条件，看它是否为真，如果为真，执行某些命令，否则，执行其他操作:</p>



<p><code>``<br/>if [[ true ]]; then<br/>command<br/>else<br/>command<br/>fi<br/>``</code></p>



<p aria-hidden="true" class="wp-block-spacer">Shell脚本While循环</p>



<div class="callout">
<div class="callout-content">
<p>shell脚本中的while循环使用以下过程:</p>

</div>
</div>



<p aria-hidden="true" class="wp-block-spacer">测试某个条件是否为真，如果为真，则重新执行命令，否则，停止并转到脚本的下一部分:</p>



<h2 id="shell-script-variables"><code>``<br/>while [[ true ]]; do<br/>command<br/><br/>done<br/><br/>``</code></h2>



<p>循环的外壳脚本</p>



<p>shell脚本中的for循环使用以下过程:</p>



<p>评估变量或文件，并重复运行某些命令，直到满足定义的条件或到达列表的末尾。<br/> <br/>为loop编写shell脚本最常见的两种语法是:<br/> <br/> 1。定义变量<code>i</code>，每次执行列表时，将<code>i</code>的值增加1。如果<code>i</code>等于或大于10则停止:<br/> <br/> <code>``<br/>for (( i=0; i&lt;10; i++)<br/>do<br/>    Commands<br/>done<br/>``</code> <br/> <br/> 2。对列表中的每个值运行一次命令，当没有值时停止。您可以引用命令中的值:<br/> <br/> <code>``<br/>for value in list<br/>do<br/>    commands<br/>done<br/>``</code></p>



<p>虽然不是必需的，但是shell脚本变量的一个常见的最佳实践是用大写字母命名它们。一些开发人员认为这使得阅读脚本和理解正在发生的事情变得更加容易。</p>



<p>接收用户输入的Shell脚本</p>



<p aria-hidden="true" class="wp-block-spacer">接受用户输入的shell脚本的工作方式如下:</p>



<h2 id="if-else-statement-shell-script"><code>read</code>命令将在继续之前等待shell用户的输入，并将输入保存到一个变量中。</h2>



<p><code>read VARIABLE</code></p>



<p>高级Shell脚本示例</p>



<p>尽管hello world脚本示例相当不错，但让我们来看看一个更复杂的高级shell脚本示例，它采用了我们刚刚介绍的逻辑。每一步都将通过行内注释来解释。虽然您可以复制/粘贴整个示例，但我们鼓励您实际输入它以获得一些肌肉记忆。</p>



<p aria-hidden="true" class="wp-block-spacer"><code>``<br/>#!/bin/bash<br/># Clear the screen when this script runs<br/>clear </code></p>



<h2 id="shell-script-while-loop"><code># Ask for the user name and await user input, store the input in NAME<br/>echo "What is your first name" &amp;&amp; read NAME</code></h2>



<p><code># Print NAME to screen in a greeting<br/>echo "Hi $NAME"<br/>echo ""</code></p>



<p><code>#Create a list of things to like or dislike<br/>LIKELIST='dogs cats movies books'</code></p>



<p><code># Loop through each value on the list that just was created<br/>for LIKE in $LIKELIST<br/>do<br/>    # Ask the user if they like the current value from the list and store the answer in LIKEANSWER<br/>    echo "Do you like $LIKE? (Answer only y or n)" &amp;&amp; read LIKEANSWER</code></p>



<p aria-hidden="true" class="wp-block-spacer"><code># If they reply with a lower case 'y', print a positive reply<br/>    if [[ $LIKEANSWER == 'y' ]]; then<br/>        echo "Awesome! I like $LIKE too!"<br/>        echo ""     <br/>        # Echoing "" prints a new line to the screen.</code> <br/> <br/> T1】</p>



<h2 id="shell-script-for-loop"><code>echo "That's OK. I understand not everyone is a $LIKE person "<br/>        echo ""</code></h2>



<p><code>fi</code></p>



<p><code>done</code></p>



<p aria-hidden="true" class="wp-block-spacer"><code># Tell the user thank you<br/>echo "Thanks for running this script!"<br/>echo ""``</code></p>



<h2 id="shell-script-input-from-user">在保存文件、运行<code>chmod 755</code>并执行脚本之后，您应该会看到如下内容:</h2>



<p><code>read</code>命令将在继续之前等待shell用户的输入，并将输入保存到一个变量中。</p>



<p><code>read VARIABLE</code></p>



<p>上面的例子使用了本系列中没有介绍的一些语法和命令，旨在鼓励您更多地探索shell脚本。有许多很棒的指南和大量的文档可用——只需在网上搜索一下！</p>



<p aria-hidden="true" class="wp-block-spacer">Git挂钩是Shell脚本</p>



<h2 id="advanced-examples">在您的存储库的<code>.git</code>文件夹中有一个名为<code>hooks</code>的目录。默认情况下，该文件夹包含13个文件名为<code>commit-msg.sample</code>、<code>pre-push.sample</code>、<code>pre-rebase.sample</code>的文件。</h2>



<p><code>``<br/>#!/bin/bash<br/># Clear the screen when this script runs<br/>clear </code></p>



<p><code># Ask for the user name and await user input, store the input in NAME<br/>echo "What is your first name" &amp;&amp; read NAME</code></p>



<p>所有这些文件都是对应于Git工作流中特定事件的shell脚本。要允许Git在相关触发发生时运行这些shell脚本，只需从文件名中删除<code>.sample</code>。Git专门寻找没有扩展名的文件。<br/> <br/>这些文件中有各种各样的例子来帮助你更好地利用Git，你可以编写自己的shell脚本来自动化任何事情。<br/> <br/>为了好玩，试着在<code>commit-msg</code>钩子上添加下面一行:<br/> <br/> <code>curl -s <a href="https://icanhazdadjoke.com" target="_blank" rel="noreferrer noopener">https://icanhazdadjoke.com</a> &amp;&amp; echo ""</code></p>



<p><code>#Create a list of things to like or dislike<br/>LIKELIST='dogs cats movies books'</code></p>



<p><code># Loop through each value on the list that just was created<br/>for LIKE in $LIKELIST<br/>do<br/>    # Ask the user if they like the current value from the list and store the answer in LIKEANSWER<br/>    echo "Do you like $LIKE? (Answer only y or n)" &amp;&amp; read LIKEANSWER</code></p>



<p>虽然可能不是最专业的例子，但您现在知道如何向Git挂钩添加逻辑了！爱德华·汤普森从他的工具git-dad 中获得的灵感<a href="https://github.com/ethomson/git-dad" target="_blank" rel="noreferrer noopener">归功于</a><a href="https://www.gitkraken.com/gitkon/history-of-git" target="_blank" rel="noreferrer noopener">。</a></p>



<p><code>echo "That's OK. I understand not everyone is a $LIKE person "<br/>        echo ""</code></p>



<p>GitKraken客户端支持各种各样的钩子操作，比如提交、重置、推送等等，使得设置Git钩子变得轻而易举，甚至对于脚本初学者也是如此。<br/></p>



<p><code>done</code></p>



<p>CI/CD管道依赖于Shell脚本</p>



<p>作为现代开发人员，您需要shell脚本技能的一个更实际的原因是因为它们在CI/CD管道中的使用。从简化的角度来看，CI/CD服务只是在远程服务器上运行shell脚本来引发操作。当然，还有许多附加功能，如内置于CI/CD平台的秘密管理和应用程序监控，如<a href="https://circleci.com/" target="_blank" rel="noreferrer noopener"> CircleCI </a>、<a href="https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/" target="_blank" rel="noreferrer noopener"> GitHub Actions </a>和<a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noreferrer noopener"> GitLab </a>，但在本质上，它们只是执行脚本。<br/> <br/>例如，下面是GitLab 的<a href="https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/templates/Bash.gitlab-ci.yml" target="_blank" rel="noreferrer noopener"> Bash工作流模板的一部分:</a></p>



<p><code>``<br/></code><br/><code>before_script:<br/>  - echo "Before script section"</code><br/><code> - echo "For example you might run an update here or install a build dependency"<br/>  - echo "Or perhaps you might print out some debugging details"after_script:<br/>  - echo "After script section"</code>T5】</p>



<p aria-hidden="true" class="wp-block-spacer">虽然您可能没有使用Bash作为实际的shell脚本语言，但是一旦您了解了一种脚本语言的工作原理，您就基本上理解了所有脚本语言的工作原理，尽管语法会有所不同。</p>





<p aria-hidden="true" class="wp-block-spacer">每一个CI/CD平台的细节都需要花时间去深入学习，但是拥有基本的shell脚本知识意味着您可以走得更远、更快。</p>



<p>每一个CI/CD平台的细节都需要花时间去深入学习，但是拥有基本的shell脚本知识意味着您可以走得更远、更快。</p>



<p aria-hidden="true" class="wp-block-spacer">考虑为开源做贡献</p>



<h2>在我们结束CLI系列介绍之前，我想最后鼓励大家分享您的工作，并考虑为开源做出贡献。本系列中的所有内容都来自于研究开源工具的文档和阅读许多代码示例。</h2>



<p>所有的开发人员都站在巨人的肩膀上，大多数时候不知道你的共享代码的哪一部分可能会对其他人有所帮助。</p>



<p aria-hidden="true" class="wp-block-spacer">但是，注意不要在公共存储库中共享密码和配置信息，但是如果您编写了一个简洁的脚本来解决特定的问题，可以考虑在公共存储库中共享它，并在自述文件中写下它是如何帮助您的。</p>





<p aria-hidden="true" class="wp-block-spacer">Shell脚本资源</p>



<p>有许多资源可以用来学习更多关于shell脚本的知识。以下是四点建议:</p>



<p aria-hidden="true" class="wp-block-spacer"><a href="https://www.codecademy.com/catalog/language/bash" target="_blank" rel="noreferrer noopener"> Codecademy的Bash/Shell课程</a></p>





<p aria-hidden="true" class="wp-block-spacer"><a href="https://guide.bash.academy/" target="_blank" rel="noreferrer noopener">巴什学院</a></p>



<p><a href="https://ryanstutorials.net/bash-scripting-tutorial/" target="_blank" rel="noreferrer noopener"> Ryans教程–Bash脚本教程</a></p>



<p aria-hidden="true" class="wp-block-spacer"><a href="https://linuxhint.com/30_bash_script_examples/" target="_blank" rel="noreferrer noopener"> LinuxHint的30个Bash脚本示例</a></p>



<div class="callout">
<div class="callout-content">
<p><a href="https://linuxhint.com/30_bash_script_examples/" target="_blank" rel="noreferrer noopener"> LinuxHint的30个Bash脚本示例</a></p>

</div>
</div>



<p aria-hidden="true" class="wp-block-spacer">已经踏上探索和学习之旅的开发人员社区也是一个惊人的资源；我们都曾经是个彻头彻尾的菜鸟。永远不要害怕寻求帮助。</p>



<h2>感谢您了解CLI的含义。无论你是谁，如果你使用计算机，学习使用命令行界面是变革性的。没什么好害怕的，学习这些工具的好处远远超过了成本。GitKraken的一套<a href="https://www.gitkraken.com/" target="_blank" rel="noreferrer noopener"> Git工具</a>旨在帮助开发人员加速学习之旅。<a href="https://www.gitkraken.com/cli" target="_blank" rel="noreferrer noopener"> GitKraken CLI </a>的自动完成建议将帮助你浏览文件系统，并像专业人士一样使用Git。GitLens 将帮助你更好地与其他开发者合作，让每一行的作者和提交历史更加清晰。我们邀请您下载并安装这两者，以便在您的旅程中充分利用CLI shell！</h2>



<p><code>``<br/></code> <br/> <code>before_script:<br/>  - echo "Before script section"</code> <br/> <code> - echo "For example you might run an update here or install a build dependency"<br/>  - echo "Or perhaps you might print out some debugging details"after_script:<br/>  - echo "After script section"</code> <br/></p>



<p>虽然您可能没有使用Bash作为实际的shell脚本语言，但是一旦您了解了一种脚本语言的工作原理，您就基本上理解了所有脚本语言的工作原理，尽管语法会有所不同。</p>



<p>每一个CI/CD平台的细节都需要花时间去深入学习，但是拥有基本的shell脚本知识意味着您可以走得更远、更快。</p>



<p>The ins and outs of every CI/CD platform takes time to learn deeply, but having basic shell scripting knowledge means you can get a lot further, a lot faster.  </p>



<p aria-hidden="true" class="wp-block-spacer">考虑为开源做贡献</p>



<h2>在我们结束CLI系列介绍之前，我想最后鼓励大家分享您的工作，并考虑为开源做出贡献。本系列中的所有内容都来自于研究开源工具的文档和阅读许多代码示例。</h2>



<p>所有的开发人员都站在巨人的肩膀上，大多数时候不知道你的共享代码的哪一部分可能会对其他人有所帮助。</p>



<p>但是，注意不要在公共存储库中共享密码和配置信息，但是如果您编写了一个简洁的脚本来解决特定的问题，可以考虑在公共存储库中共享它，并在自述文件中写下它是如何帮助您的。</p>



<p>Shell脚本资源</p>



<p aria-hidden="true" class="wp-block-spacer">有许多资源可以用来学习更多关于shell脚本的知识。以下是四点建议:</p>



<h2><a href="https://www.codecademy.com/catalog/language/bash" target="_blank" rel="noreferrer noopener"> Codecademy的Bash/Shell课程</a></h2>



<p><a href="https://guide.bash.academy/" target="_blank" rel="noreferrer noopener">巴什学院</a></p>



<ol><li><a href="https://ryanstutorials.net/bash-scripting-tutorial/" target="_blank" rel="noreferrer noopener"> Ryans教程–Bash脚本教程</a></li><li><a href="https://linuxhint.com/30_bash_script_examples/" target="_blank" rel="noreferrer noopener"> LinuxHint的30个Bash脚本示例</a></li><li><a href="https://ryanstutorials.net/bash-scripting-tutorial/" target="_blank" rel="noreferrer noopener">Ryans Tutorials – Bash Scripting Tutorial</a></li><li>已经踏上探索和学习之旅的开发人员社区也是一个惊人的资源；我们都曾经是个彻头彻尾的菜鸟。永远不要害怕寻求帮助。</li></ol>



<p aria-hidden="true" class="wp-block-spacer">感谢您了解CLI的含义。无论你是谁，如果你使用计算机，学习使用命令行界面是变革性的。没什么好害怕的，学习这些工具的好处远远超过了成本。GitKraken的一套<a href="https://www.gitkraken.com/" target="_blank" rel="noreferrer noopener"> Git工具</a>旨在帮助开发人员加速学习之旅。<a href="https://www.gitkraken.com/cli" target="_blank" rel="noreferrer noopener"> GitKraken CLI </a>的自动完成建议将帮助你浏览文件系统，并像专业人士一样使用Git。GitLens 将帮助你更好地与其他开发者合作，让每一行的作者和提交历史更加清晰。我们邀请您下载并安装这两者，以便在您的旅程中充分利用CLI shell！</p>



<p>The community of developers who have been on this journey of discovery and learning is an amazing resource as well; we’ve all been a complete noob at one point.  Never be afraid to ask for help. </p>



<p>Thank you for learning what the CLI stands for. No matter who you are, if you use a computer, learning to use the CLI shell is transformative. There is nothing to fear and the benefits of learning these tools far and away outweigh the costs.<br/><br/>GitKraken’s set of <a href="https://www.gitkraken.com/" target="_blank" rel="noreferrer noopener">Git tools</a> are designed to help speed developers on your learning journey.  The <a href="https://www.gitkraken.com/cli" target="_blank" rel="noreferrer noopener">GitKraken CLI</a>‘s autocomplete suggestions will help you navigate the file system and use Git like a pro in no time. <a href="https://www.gitkraken.com/gitlens" target="_blank" rel="noreferrer noopener">GitLens</a> will help you collaborate better with other developers by making each line’s authorship and commit history more clear.  We invite you to download and install both to make the best use of the CLI shell on your journey! </p>
		</div>
				</div>    
</body>
</html>