<html>
<head>
<title>Stacked Pull Requests | GitKon 2022 | Tomas Reimers, Graphite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>堆叠拉动请求| GitKon 2022 | Tomas Reimers，Graphite</h1>
<blockquote>原文：<a href="https://www.gitkraken.com/gitkon/stacked-pull-requests-tomas-reimers#0001-01-01">https://www.gitkraken.com/gitkon/stacked-pull-requests-tomas-reimers#0001-01-01</a></blockquote><div><div class="elementor-widget-container">
			
<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><p class="wp-block-embed__wrapper"><iframe title="Stacked Pull Requests | GitKon 2022 | Tomas Reimers, Graphite" src="https://www.youtube.com/embed/U8wJoxxmskM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">视频</iframe></p></figure>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3><strong>保持畅通并快速发展的工作流程</strong></h3>



<p>假设你是一家社交媒体公司的软件开发人员。您的公司有帖子，现在想添加评论和反应。评论是对帖子的回应，反应是对评论的回应。</p>



<p aria-hidden="true" class="wp-block-spacer"/>





<p aria-hidden="true" class="wp-block-spacer"/>



<h2><strong>大量拉取请求的问题</strong></h2>



<p>作为一名勤奋的开发人员，您为评论特性发布了一个<a href="https://www.gitkraken.com/learn/git/tutorials/what-is-a-pull-request-in-git" target="_blank" rel="noreferrer noopener"> Git pull请求</a> (PR)。假设你想在你的PR评论里增加2000行左右；在这种情况下，您有几个选择。</p>



<ol><li>添加对评论的反应。这使得PR更长，甚至更不可能被审查。</li><li>麻烦一个评论家接受你的公关，这样你就可以合并它，继续发展。在这种情况下，您已经中断了您的团队成员的工作流程，并请求加速评审，这导致了在低质量的评审中错误被合并的风险。</li><li>你可以继续做别的事情。</li></ol>



<p aria-hidden="true" class="wp-block-spacer"/>



<p>因为当前的特性分支模型要求你从主分支中分支出来，所以当开发人员需要将代码合并回主项目时，他们会感到受阻。</p>



<p>许多开发人员不知道这里实际上有一个隐藏的选项4:如果您不必从main分支会怎么样？相反，如果我们从评论分支分出并开始反应分支会怎么样？</p>



<p>更进一步说，您甚至需要对拉取请求进行注释吗？在大多数情况下，注释描述了一组相关的更改:一个针对数据库，一个针对服务器，一个针对客户端。如果你能把它们分解成单个的PRs会怎么样？</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2><strong>堆叠拉取请求</strong></h2>



<p>这将产生一组较小的拉请求，其好处众所周知。根据<a href="https://google.github.io/eng-practices/review/developer/small-cls.html" target="_blank" rel="noreferrer noopener"> GitHub Pull请求作者指南</a>，较小的PRs会导致:</p>



<ol><li>更好的评论，因为评论者不太可能沮丧和盲目盖章。</li><li>更快的合并，因为审阅者将能够更快地审阅。</li><li>更少的<a href="https://www.gitkraken.com/learn/git/tutorials/how-to-resolve-merge-conflict-in-git" target="_blank" rel="noreferrer noopener"> Git合并冲突</a>，因为更少的工作意味着更少的冲突。</li></ol>



<p aria-hidden="true" class="wp-block-spacer"/>



<p>所有这些听起来都很理想，那么为什么堆栈式拉取请求工作流没有变得更常见呢？有几个原因:</p>



<ol><li>Git rebases 是一场噩梦。到目前为止，最大的障碍是，如果你需要改变你分支的公关会发生什么。如果你这样做了，任何依赖的分支都需要在新的分支上重定基础，并且任何依赖于那些分支的分支本身也需要重定基础。</li><li>很难跟踪依赖关系。对于作者和审阅者来说，一旦您开始管理具有三个或更多拉取请求的堆栈，就很难记住PR的位置。</li><li>怎么一次合并很多东西？你应该如何用现代的<a href="https://www.gitkraken.com/blog/code-review" target="_blank" rel="noreferrer noopener">代码审查</a>工具做到这一点呢？您可以合并一个，必须将back base upstack放在上面，然后合并下一个。</li></ol>



<p aria-hidden="true" class="wp-block-spacer"/>



<p>好消息是有质量开发工具<a href="https://www.gitkraken.com/" target="_blank" rel="noreferrer noopener">可以帮助管理堆叠的拉请求工作流。</a></p>



<p>管理栈的工具有很多；例如，<a href="https://graphite.dev/" target="_blank" rel="noreferrer noopener"> Graphite </a>将自动为您处理重定基础，可视化堆栈，并为合并堆栈提供自动化。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<figure class="wp-block-image size-large"><picture decoding="async" class="wp-image-9231">
<source type="image/webp" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-819x1024.png.webp 819w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-1228x1536.png.webp 1228w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5.png.webp 1308w" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20819%201024'%3E%3C/svg%3E" data-lazy-sizes="(max-width: 819px) 100vw, 819px"/>
<img decoding="async" src="" alt="Graphite showing the status of stacked pull requests" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-819x1024.png 819w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-240x300.png 240w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-768x961.png 768w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-1228x1536.png 1228w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5.png 1308w" data-lazy-sizes="(max-width: 819px) 100vw, 819px" data-lazy-src="https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-819x1024.png"/>
</picture>
<noscript><picture decoding="async" class="wp-image-9231">
<source type="image/webp" srcset="https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-819x1024.png.webp 819w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-1228x1536.png.webp 1228w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5.png.webp 1308w" sizes="(max-width: 819px) 100vw, 819px"/>
<img decoding="async" src="../Images/1e4979cd29f88f7d0c4dbed137d7995d.png" alt="Graphite showing the status of stacked pull requests" srcset="https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-819x1024.png 819w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-240x300.png 240w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-768x961.png 768w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-1228x1536.png 1228w, https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5.png 1308w" sizes="(max-width: 819px) 100vw, 819px" data-original-src="https://www.gitkraken.com/wp-content/uploads/2022/10/image1-5-819x1024.png"/>
</picture>
</noscript></figure>



<p aria-hidden="true" class="wp-block-spacer"/>





<p aria-hidden="true" class="wp-block-spacer"/>



<p>比使用任何特定工具更重要的是开始堆叠您的更改，这样您就可以编写更小的拉式请求，获得更好的评论，并更快地发布特性。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2><strong>获得石墨堆叠&amp; GitKraken </strong>客户端</h2>



<p>除了使用Graphite管理堆叠的PRs之外，还可以考虑将<a href="https://www.gitkraken.com/git-client" target="_blank" rel="noreferrer noopener"> GitKraken客户端</a>添加到您的工具带上。交互式拉式请求管理允许您在不离开应用程序的情况下查看、评论、合并和批准拉式请求。</p>
		</div>
				</div>    
</body>
</html>