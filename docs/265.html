<html>
<head>
<title>Introducing Node Sentinel File Watcher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>介绍节点哨兵文件监视器</h1>
<blockquote>原文：<a href="https://www.gitkraken.com/blog/node-sentinel-file-watcher#0001-01-01">https://www.gitkraken.com/blog/node-sentinel-file-watcher#0001-01-01</a></blockquote><div><div class="elementor-widget-container">
			
<h3><strong> Node whatnow？</strong></h3>



<p>节点哨兵文件守望者(<a href="https://www.gitkraken.com/nsfw" target="_blank" rel="noreferrer noopener"> NSFW </a>)。这是一个为Node.js构建的文件监视模块。我构建NSFW是为了克服我们在开发<a href="https://www.gitkraken.com/" target="_blank" rel="noreferrer noopener"> GitKraken </a>时遇到的一个障碍，我将它作为一个正在进行的开源项目发布。它实际上对工作完全安全。甚至是最理想的。</p>



<p>NSFW是一个本地节点模块，这意味着它被开发和编写为在没有解释器的操作系统上本地运行(JavaScript使用解释器，而像C++这样的语言编译成机器代码)。</p>



<p>NSFW有一个针对Linux、MacOS和Windows的文件监视实现，这些实现被包装和绑定以供节点运行时使用。由于它的本地实现，NSFW能够以一种非常高效的方式观察所有操作系统上的递归目录。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3>NSFW解决了什么问题？</h3>



<p>目前，Node对文件监视的支持很差。每个操作系统都有不同的能力来监视目录。以下是一些名人在推特上说的话:</p>











<p>Linux不能执行递归目录监视。当文件被更改时，MacOS不提供文件名。</p>



<p>除此之外，还有一个事实是，对于节点的文件监视器来说，还有<a href="https://github.com/nodejs/node-v0.x-archive/search?q=fs.watch&amp;type=Issues" target="_blank" rel="noreferrer noopener">许多未解决的问题</a>，并且节点在不同的操作系统之间没有一致的体验。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3>NSFW是如何解决这个问题的？</h3>



<p>NSFW通过利用3个用C++编写的低级文件查看实用程序，针对Linux、MacOS和Windows操作系统，解决了Node上较差的文件查看体验。</p>



<p>NSFW在一个单独的线程上完成大部分工作，与内置的节点文件系统(FS)观察器API相比，它的性能有了很大提高。NSFW在单独的线程上对文件事件进行排队，并将文件更改调度批处理到单个回调中。该回调可以在内部进行调节，以防止JavaScript/C++桥垃圾邮件。</p>



<p>这意味着NSFW不会降低JavaScript应用程序的速度，即使它们处于大型文件系统操作的负载下。</p>



<p>Linux、MacOS和Windows都有自己的文件监控API。由于NSFW的手表实用程序专门针对这些API，这意味着使用该模块的体验在所有三个操作系统中是一致的。NSFW填补了每个API的空白，因此它们都具有一致的功能完整性:</p>



<ul><li><strong>Linux:</strong><code>Inotify</code>文件监视系统不执行递归目录监视，所以NSFW为你建立并维护一个递归监视树。</li><li><strong>众所周知，MacOS: </strong> <code>FSEvents</code>会产生不一致的文件事件(如果事件发生得太快，文件事件<code>bitmask</code>会损坏)，因此NSFW为您统计并消除文件更改事件的歧义。</li><li><strong> Windows: </strong>支持开箱即用的所有目标需求。<strong>(记录划痕)</strong>没错，<em> Windows的原生支持最好</em>。我说了。</li></ul>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3><strong>为什么这是Axosoft开发团队要解决的一个重要问题</strong></h3>



<p>GitKraken目前是NSFW的主要消费者。一个好的Git客户端不应该带有刷新按钮，因为它应该自动知道什么时候会发生变化。</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><picture decoding="async" class="wp-image-3599">
<source type="image/webp" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1.png.webp 800w" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20800%20267'%3E%3C/svg%3E" data-lazy-sizes="(max-width: 800px) 100vw, 800px"/>
<img decoding="async" src="" alt="" data-lazy-srcset="https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1.png 800w, https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1-300x100.png 300w, https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1-768x256.png 768w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1.png"/>
</picture>
<noscript><picture decoding="async" class="wp-image-3599">
<source type="image/webp" srcset="https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1.png.webp 800w" sizes="(max-width: 800px) 100vw, 800px"/>
<img decoding="async" src="../Images/055b0ce6b61849a37d4caca3020b50aa.png" alt="" srcset="https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1.png 800w, https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1-300x100.png 300w, https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1-768x256.png 768w" sizes="(max-width: 800px) 100vw, 800px" data-original-src="https://www.gitkraken.com/wp-content/uploads/2021/06/refresh-gk-800x267-1.png"/>
</picture>
</noscript><figcaption>What could have been: Imagine if GitKraken needed a refresh button like this. Gross!</figcaption></figure></div>



<p>NSFW对于GitKraken流畅的跨平台体验至关重要，因为它有助于应用程序快速准确地响应它正在查看的存储库中的变化。NSFW是一个安静、谦逊、没有虚饰的后台进程。不会兴风作浪。它不通过电影说话，不大声咀嚼，不打呼噜，但它的透明是它的长处；如果你注意到了，很可能是因为某些东西不工作了。因此，让我们为安静高效地查看文件干杯——NSFW模块让这一切变得简单。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3><strong>发展障碍</strong></h3>



<p>哦是的。</p>







<p>由于对任何文件监视API都没有经验，对Node (NAN) API的本机抽象也没有什么经验，并且对如何对Node与每个文件监视实用程序的交互进行建模也没有清晰的理解，0.x.x NSFW版本遇到了麻烦。</p>



<p>在Windows上，我尝试使用C++/CLI来使用。NET库。虽然这使得它可以快速启动并运行，但它不可避免地适得其反，因为一些用户由于缺少库依赖而无法运行GitKraken。<em>叹息</em>。</p>



<p>我还遇到了与两个不同的垃圾收集器并发运行相关的奇怪错误(一个用于节点，一个用于托管文件监视器)。当我报废了。NET实现，我为Windows操作系统实现了更强的稳定性。</p>



<p>在Linux和MacOS上，问题围绕着不熟悉文件监视API和本机结构。总体上的不熟悉加上每个操作系统所采用的不同策略，最终将整个项目变成了一堆意大利面垃圾。<code>[REDACTED: DEEMED NSFW BY THE AXOSOFT DEPARTMENT OF PROPAGANDA]</code></p>



<p>最后，大型文件更改操作会降低每个操作系统的速度。当时，这些消息没有节流行为。节点应用程序会受到文件系统更改通知的严重影响，速度慢得像爬行一样。在GitKraken中，每当我们执行引导过程时，都会遭受这样的后果，这涉及到大量的文件操作。</p>



<p>在0.x.x个月(又名<em>黑暗时期</em>)摆弄完这个项目后，我学到了很多关于每个底层文件监视器API如何工作的知识，包括它们的警告、要求和漏洞。</p>



<p>在花了一周时间拼凑了一个完整的系统图后，我把整个0.x.x项目都报废了，重新构建项目，有计划地处理各个操作系统的差异。我还放弃了C++/CLI界面，选择了Windows中的<code>ReadDirectoryChangesW</code>。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3><strong>几个经验教训</strong></h3>



<ol><li>预测一个系统的架构而没有先用核心特性弄脏你的手，意味着你可能最终会扔掉你的项目，用核心特性弄脏你的手，然后重新开始这个项目。作为一个新的开发者，准备好扔掉你的原型。</li><li>我不确定C++/CLI和Node是否应该成为一个东西。永远不会。</li></ol>
		</div>
				</div>    
</body>
</html>