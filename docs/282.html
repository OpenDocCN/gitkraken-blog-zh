<html>
<head>
<title>Making GitHub Enterprise Support a Reality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>让GitHub企业支持成为现实</h1>
<blockquote>原文：<a href="https://www.gitkraken.com/blog/github-enterprise-support#0001-01-01">https://www.gitkraken.com/blog/github-enterprise-support#0001-01-01</a></blockquote><div><div class="elementor-widget-container">
			
<p>你要求的，所以我们在GitKraken v1.9中让GitHub Enterprise支持成为现实！这意味着有了GitKraken Pro，您在GitKraken中了解和喜爱的所有酷GitHub.com集成，现在也可以为您的GitHub企业存储库所用。</p>



<p>想了解更多关于GitHub企业支持的信息吗？接着读下去！升级到GitKraken Pro后，您还可以体验所有其他<a href="https://www.gitkraken.com/pro" target="_blank" rel="noreferrer noopener">酷功能</a>。</p>



<figure class="wp-block-pullquote"><blockquote><p>开发团队对集成带来的新问题进行了一系列潜在的解决方案，并提出了几个可行的解决方案。</p></blockquote></figure>



<p aria-hidden="true" class="wp-block-spacer"><strong>选项</strong></p>



<h2>使GitHub Enterprise与我们的GitHub.com集成不同的一个原因是，我们不能依赖GitKraken的API服务器作为客户端和GitKraken试图与之交互的服务之间的中介。</h2>



<p>GitKraken使用OAuth与GitHub.com通信，这意味着该应用程序代表GitKraken请求用户允许在服务中为用户执行部分操作。这一切都是可行的，因为GitKraken可以向服务证明，它确实是为用户请求这些权限的人，通过使用“秘密”密钥，保存在API服务器上，而不是与应用程序本身共享。</p>



<p>在GitHub Enterprise的例子中，这种逻辑在某种程度上是不成立的，因为API服务器不能真正知道它可能需要认证的所有可能的GitHub Enterprise服务器。即使可以，也必须在每个GitHub Enterprise实例上生成一个“秘密”密钥。</p>



<p>GitKraken dev团队针对潜在的GitHub企业集成所带来的新问题，研究了一系列潜在的解决方案，并提出了几个可行的解决方案:</p>



<p>The GitKraken dev team went through a litany of potential solutions for the new problems posed by the potential GitHub Enterprise integration and came up with a couple feasible solutions:</p>



<p aria-hidden="true" class="wp-block-spacer"><strong> 1。发布一个独立的API服务器。</strong></p>



<h3>一种想法是部署一个独立的API服务器，可以为每个GitHub企业实例设置，大概是由GitHub企业所有者的IT部门或负责维护GitHub企业实例的任何人设置。这里的缺点是，在用户端(或者至少是他们的IT部门)设置这样的东西需要大量的工作。</h3>



<p>每个用户的GitKraken实例除了已经需要知道GitHub企业实例在哪里之外，还需要知道API服务器在哪里。我们还必须构建前面提到的独立API服务器，测试它，并为它制作文档。基本上，每个人都有很多工作要做。如果你问我，我会说这是非常不合逻辑的。</p>



<p>Each user’s GitKraken instance would also need to know where that API server is, in addition to already needing to know where the GitHub Enterprise instance is. We’d also have to build the aforementioned standalone API server, test it, and make documentation for it. Basically, it’d be a lot of work for everyone. Highly illogical if you ask me.</p>



<p aria-hidden="true" class="wp-block-spacer"><strong> 2。让GitKraken充当API服务器，并允许用户系统上的配置文件处理所需的配置。</strong></p>



<h3>这个想法有一些非常有趣的成分。这将通过允许在用户的系统上放置一个JSON配置文件(可能是由他们的IT部门)来实现，该文件将包含允许用户的GitKraken应用程序充当API服务器的必要信息。这实际上可能听起来比实际简单得多。</h3>



<p>OAuth的一个优点是它允许用户给应用程序权限来代表他们做事情，而不需要与应用程序共享他们的密码。只有当用户没有被强迫在完全由应用程序控制的地方输入他们的凭证时，这才真正起作用(几乎完全违背了OAuth的目的)。这意味着GitKraken需要将认证过程交给用户可以信任的外部应用程序(通常是他们的网络浏览器)。有趣的部分就在这一点上来了:<em>当用户完成认证过程时，浏览器如何将信息传回app？</em></p>



<p>有很多方法可以做到这一点，但是最优雅和有趣的方法(以我的拙见)是使用一个定制的协议处理器。我们实际上是告诉用户的系统，如果一个带有指定协议的URL被访问(比如<kbd>gitkraken://)</kbd>)，GitKraken应该被用来处理这个动作。</p>



<p>这将允许浏览器将身份验证过程生成的代码返回给GitKraken，因此OAuth过程可以在应用程序中完成。</p>



<p>这个流程的过程很简单:用户(或者在更大范围内，用户的IT部门)将在GitKraken设置目录中添加一个配置文件，然后在应用程序中单击一个<kbd>connect</kbd>按钮，这与当前的GitHub.com集成方式非常相似。这种想法最适合大规模应用，因为IT部门愿意并且能够为用户实现流程自动化。</p>



<p>The process for this flow would simply be: the user (or on a larger scale, the user’s IT department) would add a single configuration file within the GitKraken settings directory, and then click a <kbd>connect</kbd> button in-app, in a fashion very similar to the current GitHub.com integration. This idea works best on a large scale where there’s an IT department willing and able to automate the process for the user.</p>



<p aria-hidden="true" class="wp-block-spacer"><strong> 3。使用个人访问令牌。</strong></p>



<h3>GitHub(实际上还有许多其他服务)允许您生成一个令牌，它可以被赋予与OAuth令牌相同的权限子集，并且可以以几乎相同的方式使用。一旦我们有了其中的一个令牌，就可以用它来代替OAuth令牌，我们可以通过GitKraken的API服务器执行身份验证过程来获得OAuth令牌。</h3>



<p>它要求用户进行一些额外的配置，但是考虑到我们需要知道GitHub Enterprise server的位置，一些额外的配置是必要的，并且有一些方法可以使配置变得非常容易。</p>



<p><strong>决定</strong></p>



<p aria-hidden="true" class="wp-block-spacer">IT辅助配置途径(2)和个人访问令牌(3)是考虑最多的两个选项。我们最终决定将个人访问令牌作为该特性的一个很好的起点。</p>



<h2>如果说使用GitHub APIs教会了我们什么的话，那就是它们非常擅长让很多事情变得非常简单。</h2>



<p>这不仅是因为实现相对容易，还因为它不是基于这样的假设，即所有GitHub Enterprise用户都有一个it部门能够通过创建配置文件并将其注入到用户的GitKraken设置中来为他们自动化该过程。</p>



<figure class="wp-block-pullquote"><blockquote><p>个人访问令牌也不排除配置文件的使用，因此，如果对稍微简化的流程有很大的需求，我们可以在未来对更大的团队进行扩展。</p></blockquote></figure>



<p>使个人访问令牌尽可能简单的另一个重要部分是确保它需要尽可能少的用户交互。不幸的是，我们不得不把用户引导到一个有着太多选项的页面:</p>



<p>如果能通过为用户填写这个表单来简化这个过程，而不是让他们来回跑来跑去以确保他们拥有所有必要的范围，那就太好了。</p>



<p>我们找不到任何文档来支持可能有方法自动检查这些框的理论，但如果使用GitHub APIs教会了我们什么，那就是它们真的很擅长让许多事情变得非常简单，甚至在没有文档的情况下。</p>







<p>经过一点小小的改动，我们发现您可以选中这些框并指定一个描述默认值，只需传递几个查询字符串参数。谢谢GitHub！</p>



<p><strong>执行</strong></p>



<p>一旦个人访问令牌到位，GitHub Enterprise几乎就是API级别的GitHub.com的替代产品。说真的，我们用来处理获取和更新用户信息、存储库、拉请求和SSH密钥的包，只是在指向GitHub企业服务器而不是GitHub.com时，以及在给定个人访问令牌而不是OAuth令牌时才工作。太棒了。这意味着我们添加到GitHub.com的大多数未来集成点可能会免费自动在GitHub Enterprise中工作。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2><strong>Execution</strong></h2>



<p>Once personal access tokens were in place, GitHub Enterprise was almost literally a drop-in replacement for GitHub.com at the API level. Seriously, the package that we use to handle fetching and updating user info, repositories, pull requests and SSH Keys, just worked when pointed at a GitHub Enterprise server, instead of GitHub.com, and when given a personal access token instead of an OAuth token. Which is awesome! It means most future integration points we add to GitHub.com will likely automatically work in GitHub Enterprise for free.</p>
		</div>
				</div>    
</body>
</html>