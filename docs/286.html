<html>
<head>
<title>Performance Problems &amp; Solutions in React.js: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React.js中的性能问题和解决方案:第1部分</h1>
<blockquote>原文：<a href="https://www.gitkraken.com/blog/performance-solutions-react-js-pt-1#0001-01-01">https://www.gitkraken.com/blog/performance-solutions-react-js-pt-1#0001-01-01</a></blockquote><div><div class="elementor-widget-container">
			
<h3>这是4部分系列的第1部分！</h3>



<p>这篇文章是关于GitKraken开发者所面临的性能问题的4篇系列文章的第一篇。这篇文章概述了问题本身，本系列的后续文章将集中讨论每个问题的解决方案是如何开发的。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h2><strong>第一部分:问题</strong></h2>



<p>这听起来可能很明显，但为了改进一个应用程序，你必须找出痛点，并准确地找出导致它们的原因。</p>



<p>我们在GitKraken中注意到的一个主要问题是，存储库越大，速度越慢。我们使用了一些工具来更具体地了解这种性能下降的根源；比如电子版的Chrome开发工具，它包含一个分析器，可以很方便地让你知道你大部分时间都花在哪里了。</p>







<p class="has-text-align-center"><em>git kraken中某个动作的简介</em></p>



<p>经过一些调查，很明显这个应用程序在React进程中花费了大量不受欢迎的时间，频繁地渲染和更新。幸运的是，React有自己的<a href="https://facebook.github.io/react/docs/perf.html" target="_blank" rel="noreferrer noopener">工具来发现性能问题</a>，所以我们能够转移到这个工具上来获得更细粒度的问题。结果是大部分花费的时间都在图表中，而且大部分是我们在软件开发行业中喜欢称之为<em>浪费的时间</em>。浪费的时间可能正是你所期望的——它是花费在原本不需要的过程中的时间。</p>



<p>在React的上下文中，这个过程要经历一个完整的渲染周期，包括获取新数据、更新组件、渲染和构建虚拟DOM。最后，您将<em>实际的</em> DOM与虚拟DOM进行比较，您可能会得出这两个DOM是相同的结论。这是浪费时间，因为不需要进行实际的DOM更新，而且您只是做了一堆徒劳的工作。<em>没什么！</em></p>



<p>这种情况开始慢慢变成浪费时间。浪费几秒钟的时间可能<em>看起来</em>不太喜欢，但在《计算机世界》中，浪费几秒钟的时间堪比观看《T2迷失》第五季:这看起来似乎是有意义的，你已经走了这么远，所以你需要看到它完成，但实际上这需要耗费大量的时间，变得越来越令人恼火，并最终成为真正糟糕的用户体验。</p>







<p class="has-text-align-center">呀呀。</p>



<p>不管怎样…重点是，在这个时候，GitKraken的每个动作都会导致图形渲染。这是每个动作的<em>，即使没有refs改变(例如，如果一个新的PR通过，或者图表上的一个时间线被更新)，整个图表刷新仍然会被执行。随后频繁的存储库刷新，以及图形渲染过程本身的缓慢，让整个应用程序感觉很慢。</em></p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3><strong>尝试解决方案#1:卸载图形</strong></h3>



<p>我们试图通过在加载时卸载图形来解决这个问题。因此，在这个过程中，整个图形组件将从React中删除。这增加了存储库的加载速度，但结果是，这种方法的特殊应用数量会使应用程序代码更加复杂，长期可持续性更差。</p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3><strong>尝试解决方案#2: Flux实现和Immutable.js </strong></h3>



<p>在我们当时的Flux实现中，每个域都有一个存储，当一个域被更新时，这个更新会导致图形的刷新。但是，如果你有一个大的刷新，有多个域更新，你会得到一个级联效果的图形刷新计算每一个域更新。在实际的用例环境中，刷新一个存储库实际上会导致大约8个图形重新呈现器，对应用程序产生显著的性能影响。</p>



<p>为什么关于Flux如何运作的一个快速背景:有一个数据调度，这个调度从一个商店到另一个商店，在它前进的过程中更新东西。如果数据发生变化，每个存储都会发出一个事件，表明某些数据已经发生变化。React然后响应这个事件，从存储中获取新数据并执行一个呈现过程。</p>



<p>这一切都很好，但这里的问题是，在渲染过程完全解决之前，没有后续的存储会更新。因此，对于更新多个存储的单个数据调度，这种连锁效应的成本会很高。这是我们实现Flux的一个基本瓶颈。</p>



<p>渲染过程本身加剧了这种性能损失。当你从商店中抓取新数据时，商店会给你一个数据的<em>深层副本</em>，而不是它的<em>实际</em>原始数据，以保护原始数据免受任何可能由天真编写的React组件引起的突变。我们已经为我们的罪过忏悔，现在跟随<em>一条真正的道路</em>。</p>



<p>这种深度复制被证明是昂贵的。当一个组件获得该数据副本时，它将在该数据(从存储中复制的)和它已经拥有的数据之间执行深度比较，以确定是否需要更新。</p>



<p>尽管在计算出是否需要执行更新这一点上有点节省时间，但这种检查本身是非常昂贵的。然而，这种深度比较实际上比仅仅更新要快。所有的行(图中的一个提交被认为是一行)，每一行都由多个组件和子组件组成，导致对它们的数据相同的多次验证。更快，但仍然是一个昂贵的事件链。</p>



<p>因此，我们决定引入一个名为<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noreferrer noopener"> Immutable.js </a>的库，它制作了不可变数组和对象，允许我们快速比较对象的一部分是否发生了变化，因为我们可以进行快速内存地址比较来查看的<em>是否发生了变化。虽然这很有帮助，但是如果不破坏“很多东西”就硬塞进我们现有的基础设施中，那是非常笨拙的，而且(你猜对了！)更新对象真的很慢。即使在使用内置方法批量更新时也是如此。这使得我们对数据的更新实际上比渲染花费了<em>更长的时间</em>，所以我们不得不放弃使用不可变作为解决方案。Womp womp。</em></p>



<p aria-hidden="true" class="wp-block-spacer"/>



<h3><strong>尝试解决方案#3 ( <em>奖励失败</em>):纯脚本</strong></h3>



<p>我们尝试将很多东西迁移到PureScript。然而，一旦我们开始，我们很快意识到这不适合我们的团队。</p>



<p>因此，到目前为止，我们已经确定了3个棘手的领域，这些领域导致了我们需要解决的性能问题:</p>



<ol><li>我们如何用新数据修改应用程序的状态。</li><li>从存储中检索数据。</li><li>确定如何以尽可能快速有效的方式更新UI中的组件。</li></ol>



<p aria-hidden="true" class="wp-block-spacer"/>



<p>这是主要的三点，每一点都需要我们重新思考如何构建应用程序。</p>



<p>这篇博文系列的下三部分将分别关注这些问题，我们实现的解决方案，以及我们如何实现它们。</p>
		</div>
				</div>    
</body>
</html>