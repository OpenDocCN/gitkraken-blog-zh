# Git 如何塑造了 Web 和 Jamstack

> 原文：<https://www.gitkraken.com/gitkon/netlify-jamstack-git>

[https://www.youtube.com/embed/1K6yaH4mmpo?feature=oembed](https://www.youtube.com/embed/1K6yaH4mmpo?feature=oembed)

视频

如果我们回顾一下 Git T1 的历史，我们会发现它对一切事物都产生了巨大的影响，使现代网络成为开发者和公司更好的地方。文本文件的版本控制系统与现代网络有什么特别的关系，这一点似乎并不十分明显。可能很容易认为这两个世界是不同的——web 应用程序的发展与我们实际管理这些 web 应用程序背后的源代码的方式完全不同。然而，我们越仔细观察，就越会发现 Git 对当今 web 构建方式的影响。

## **早期版本控制模式**

在 Git 之前，有其他早期的、分散的源代码控制系统，但是更流行的是集中的源代码控制管理系统，比如 Apache 的 Subversion (SVN) 。现在仍然存在的 SVN 是 web 早期非常常见的源代码控制系统。SVN 模型依赖于运行一个中央源代码管理服务器。

使用 SVN，每个存储库都必须被设置为自己的服务器，每个开发人员都要连接到该服务器，在他们自己的机器上制作本地工作副本，服务器始终是唯一的真实来源。这种中央服务器模型需要系统操作员在某个地方的机器上运行 SVN。这种操作开销使得 SVN 很难用于业余爱好项目或较小的项目。

你还迷恋 SVN 吗？Git 是未来的发展方向。不要落后–立即开始您的迁移过程！

[Migrate to Git from SVN](/blog/migrating-git-svn)

## **哇，Git 就像魔术一样**

这在今天可能看起来很平常，但是当 Git 首次发布时，你可以在任何文件夹中简单地输入‘Git init’来启动一个版本控制系统的新实例的想法是不可思议的。您在本地笔记本电脑上有一个完整的版本控制系统，无需设置和维护中央服务器。

突然，如果您对项目文件夹中的任何文件进行了更改，您就可以访问完整的 Git 状态和 [Git 历史](https://www.gitkraken.com/blog/review-file-history-git)，让您看到您的代码是如何被修改的。[简单而快速的命令](https://www.gitkraken.com/learn/git/commands)允许您将文件添加到存储库中，并让 [Git 提交](https://www.gitkraken.com/learn/git/commit)，而无需任何服务器设置、任何供应或管理任何其他服务器。这简直是开创性的。

很容易忘记，但在 Git 之前，做类似结账、[分支](https://www.gitkraken.com/learn/git/branch)，立即看到[差异](https://www.gitkraken.com/learn/git/git-diff)的事情，甚至分支之间，都是革命性的。

这完全改变了文件夹和文件在本地机器上的工作方式。Git 意味着你可以有一个 README 文件，输入一个命令来 [Git checkout](https://www.gitkraken.com/learn/git/git-checkout) 另一个分支，然后突然在你的屏幕上有一个完全不同的 README 文件。这种魔力意味着笔记本电脑上的每个文件夹都有全新的潜力，过去像在 Subversion 服务器上合并不同分支这样非常麻烦的大操作变得像输入` [git merge](https://www.gitkraken.com/learn/git/git-merge) '一样简单。

GitKraken 客户端中易于准备的提交图将帮助您可视化分支结构和项目历史，让您更有信心执行日常 Git 操作，如分支和合并。

## **从本地工作到在线协作**

当 GitHub 出现时，它允许开发人员在线创建新的存储库，并即时同步他们本地的分散文件夹。很神奇的是，作为开发人员，你几乎不需要任何设置就能做到这一点；没有服务器供应或任何类似的东西。多亏了 GitHub，一切都从本地体验变成了在线体验。您突然能够与世界上的每个人共享任何存储库！从 GitHub 本地签出它的每个人都将拥有所有的魔力和你的项目的完整副本，他们将能够使用它们。

许多过去非常困难的工作，比如管理不同的环境以及在它们之间进行合并，现在变得简单了。每一个改变都有自己的分支，你可以在线分享这些分支。

有趣的是，Git 的去中心化特性实际上使得采用集中式平台变得非常容易，比如 [GitHub](https://www.gitkraken.com/integrations/github) 、 [GitLab](https://www.gitkraken.com/integrations/gitlab) 或 [Bitbucket](https://www.gitkraken.com/integrations/bitbucket) 。开发人员可以开始围绕 URL 和工作流一起构建约定。GitHub 真正引入了将 Git 定义为云工作流工具的可能性。

## **支持全球 Git 工作流**

Git 很快从“仅仅”一个源代码版本管理工具变成了我们作为开发人员如何一起构建和发布的核心组件。GitHub 出现后，开发人员立即开始有了即时存储库的想法，每个爱好项目或任何一点代码都可以立即成为一个 [Git 存储库](https://www.gitkraken.com/learn/git/tutorials/what-is-a-git-repository)，与世界共享以进行协作。

当 GitHub，以及后来的 GitLab 和 Bitbucket 引入了" [pull request](https://www.gitkraken.com/learn/git/tutorials/what-is-a-pull-request-in-git) "或" merge request "的概念时，它真正启动了在线项目协作的世界。每个变更集都可以有自己的 URL，您可以访问它进行代码审查，这意味着整个世界可以以异步的方式协作。
如果没有这些小魔术，所有这一切都不会发生，这些小魔术将每个文件夹变成了一个存储库，在这里可以对每个变更集进行比较、拉取、推送和全球同步。

### **网络是如何变化的**

你可能还在想，“这些和网络有什么关系？Git 实际上是如何映射到 web 上的？”

如果你回想一下 SVN 流行时的网络，通常会有一个运行 Apache 的服务器，可能是一些 PHP 或 Ruby on Rails，也可能是一个 DB。你可以在本地下载代码，但是中央服务器永远是事实的唯一来源。早期的 web 浏览器更像是一个文档查看器，从服务器请求完整 web 文档的副本。

作为 SVN 世界的开发人员，您通常会操作非常长寿的分支，这些分支几乎就像它们自己的存储库，每个服务器一个。有一个生产分支，一个准备分支，有时还有一个开发分支。开发分支在 SVN 并不常见，因为处理合并和保持不同分支的同步通常非常困难。

感觉好像每个环境都需要一台服务器，即使它运行在同一个 SVN 服务器上。web 实际上反映了这种类型的服务器设置。您可能有自己的生产环境、试运行环境，有时还有我们的开发环境，但是很难让所有这些环境都保持最新和同步。在所有系统操作之间，SVN 要求语言版本和库都正确同步，并且数据在每个环境中都有表示。

## **jam stack 和 Netlify 的起源**

当 Netlify 第一次开始的时候，这实际上是因为 Matt Biilmann 和他的团队看到了 GitHub 和 Git 创造了一个新世界，在那里你可以以不同的方式进行合作。在这个世界里，现代浏览器真正开始允许你把网络当作一个独立的应用程序，你可以把它推给最终用户，让他们在自己的浏览器上运行。
你可以开始看到后端分成所有这些不同的 API 和服务。虽然您可以自己构建其中的一些，但很多都是其他人的服务。一些很棒的例子包括 [Twilio](https://www.twilio.com/) 、 [Stripe](https://stripe.com/) 、[contentiful](https://www.contentful.com/)、[Sanit](https://www.sanity.io/)y。io 和 [Algolia](https://www.algolia.com/) 。网络空间中有更多的新兴服务，这些类型的服务让我们有了术语 [Jamstack](https://www.gitkraken.com/webinar/jamstack-nextjs) 。

## **jam stack 和静态站点**

在现代 web 开发中，整个堆栈已经上升了一个级别，您可以将 UI 直接推送到浏览器，然后与所有这些不同的 API 和服务进行对话，无论是作为构建时系统还是运行时系统。这个领域的一些真正的早期先驱是杰基尔和 T2·恩伯，他们为 Jamstack 的崛起铺平了道路。

Jekyll 是一个静态站点生成器，由 GitHub 的创始人汤姆·普莱斯顿-沃纳(Tom Preston-Werner)创建，他把开发者的想法从长期运行的带有数据库的服务器和维护这种设置的所有复杂性中转移出来。它让开发人员认识到，每个网站都可以是一个带有构建步骤的 Git 存储库。这个构建步骤将知道如何获取 GitHub 中所有不同的源文件，并输出一个静态运行的现成网站，最终被推送到一个 [CDN](https://en.wikipedia.org/wiki/Content_delivery_network) 。您可以用很少的开销获得惊人的性能优势和安全特性。

Ember 是单页面应用程序框架的先驱之一。它认为浏览器更像是一个操作系统，而不是一个文档浏览器。Ember 的最早版本使用的是 Rails 应用程序，Ember 将自己注入到视图层，一切仍然耦合在一起。Ember CLI 的后续版本真正开创了一个完全解耦的 web UI 层的概念，与后端分离。这种分离意味着利用 API 只是一个实现细节，而不再是架构级别的决策。

有了今天的 Jamstack 方法，利用 API 的解耦架构已经真正成为考虑 web 的标准方式。开发者不再认为网站和应用程序存在于某个单一应用程序的模板中。开发人员现在认为网站是可以存在于他们自己的 Git 存储库中的代码，遵循他们自己的一套工作流和 [Git 分支策略](https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy)。

能够在本地工作对 Jamstack 来说非常重要。能够完全在本地工作，然后将代码上传到远程的安全性是 Netlify 的真正灵感来源。只需克隆一个 Git 存储库，您就会突然拥有一个完整的本地环境，在这里您可以使用与您的生产网站完全相同的特性工作。你脱离了运行服务器和操作数据库等等。你可以简单地提升你的本地工作，让 Netlify 担心现代网站和网络应用程序的构建、发布和操作。

Netlify 开始看到协作工作流的出现，它们从长期的生产、试运行和开发环境中脱离出来，更倾向于针对每个 bug 修复或每次发布更新的拉式请求和短期功能分支。这促使 Netlify 在 2016 年引入了“部署预览”的概念，其思想是，如果您有一个带有主 URL 的生产网站，为什么不给每个拉请求提供自己的部署预览，每个部署预览都有一个唯一的 URL，您可以根据它进行共享和协作？

[观看此视频剪辑](https://youtu.be/1K6yaH4mmpo?t=1156)观看 Netlify 首席执行官 Matt Biilmann 使用 Astro(一种构建静态网站的框架)全面演示本地开发和预览环境的原理。

## **下一代 Jamstack 工具**

Astro 是 Matt 和他在 Netlify 的团队非常感兴趣的一个框架。它允许你在构建时用现代组件库做很多非常聪明的事情，精确定义你想要的 JavaScript 和动态，并且*只*让那些部分在运行时生成 JavaScript。作为一名开发人员，您可以自由选择想要依赖的组件库和底层 UI 框架。

你可以快速构建一个本地开发环境，这个环境完全模仿你以后将会推到云端的东西。一旦它看起来正确并且在本地表现出预期的行为，您就可以将代码推送到 Git repo 并创建一个 pull 请求来启动所需的构建和部署过程。

GitKraken 使创建 pull 请求变得快速而简单，使用 GitHub 的团队获得了更多的 PR 功能，如在不离开客户端的情况下对 PR 进行评论、批准和合并。

每一次部署都有一个唯一的标识符，它会一直存在。当您发布主站点的新版本时，您可以看到正在制作的内容，但也可以看到主站点的早期版本。您还可以看到一个内容图表，其中标识了这些特定的版本，这些内容将始终可用。这些总是可以立即访问的，不需要重新加载，能够无中断地回滚或前滚代码。

## **Git 建立了去中心化的网络**

Git 天生就是去中心化的。这在概念上允许您在本地工作，并立即同步到一个远程存储库。正是这种去中心化的力量，使得 GitHub、GitLab 和 Bitbucket 等平台能够为开发人员的协作工作流做比任何早期的源代码控制平台更多的事情。开发人员可以直接围绕他们的源代码进行协作，共同构建工作流，而不是维护始终运行的 Subversion 服务器。

Netlify 应用了 Git 和 web 上的所有知识，允许开发人员在云平台上快速构建无状态、解耦的应用程序。它不仅仅是一个托管网站的地方，而是一个真正的工作流引擎，让您的整个团队更快地协作，在更短的时间内为 web 创建更好的结果。这让 Netlify 的团队非常兴奋。随着 Jamstack 的发展，每个人都将期待 Git 和那里出现的模式能够给我们所有关于接下来会发生什么的线索！