# 介绍节点哨兵文件监视器

> 原文：<https://www.gitkraken.com/blog/node-sentinel-file-watcher>

### **Node whatnow？**

节点哨兵文件守望者( [NSFW](https://www.gitkraken.com/nsfw) )。这是一个为 Node.js 构建的文件监视模块。我构建 NSFW 是为了克服我们在开发 [GitKraken](https://www.gitkraken.com/) 时遇到的一个障碍，我将它作为一个正在进行的开源项目发布。它实际上对工作完全安全。甚至是最理想的。

NSFW 是一个本地节点模块，这意味着它被开发和编写为在没有解释器的操作系统上本地运行(JavaScript 使用解释器，而像 C++这样的语言编译成机器代码)。

NSFW 有一个针对 Linux、MacOS 和 Windows 的文件监视实现，这些实现被包装和绑定以供节点运行时使用。由于它的本地实现，NSFW 能够以一种非常高效的方式观察所有操作系统上的递归目录。

### NSFW 解决了什么问题？

目前，Node 对文件监视的支持很差。每个操作系统都有不同的能力来监视目录。以下是一些名人在推特上说的话:

Linux 不能执行递归目录监视。当文件被更改时，MacOS 不提供文件名。

除此之外，还有一个事实是，对于节点的文件监视器来说，还有[许多未解决的问题](https://github.com/nodejs/node-v0.x-archive/search?q=fs.watch&type=Issues)，并且节点在不同的操作系统之间没有一致的体验。

### NSFW 是如何解决这个问题的？

NSFW 通过利用 3 个用 C++编写的低级文件查看实用程序，针对 Linux、MacOS 和 Windows 操作系统，解决了 Node 上较差的文件查看体验。

NSFW 在一个单独的线程上完成大部分工作，与内置的节点文件系统(FS)观察器 API 相比，它的性能有了很大提高。NSFW 在单独的线程上对文件事件进行排队，并将文件更改调度批处理到单个回调中。该回调可以在内部进行调节，以防止 JavaScript/C++桥垃圾邮件。

这意味着 NSFW 不会降低 JavaScript 应用程序的速度，即使它们处于大型文件系统操作的负载下。

Linux、MacOS 和 Windows 都有自己的文件监控 API。由于 NSFW 的手表实用程序专门针对这些 API，这意味着使用该模块的体验在所有三个操作系统中是一致的。NSFW 填补了每个 API 的空白，因此它们都具有一致的功能完整性:

*   **Linux:**`Inotify`文件监视系统不执行递归目录监视，所以 NSFW 为你建立并维护一个递归监视树。
*   **众所周知，MacOS:** `FSEvents`会产生不一致的文件事件(如果事件发生得太快，文件事件`bitmask`会损坏)，因此 NSFW 为您统计并消除文件更改事件的歧义。
*   **Windows:** 支持开箱即用的所有目标需求。**(记录划痕)**没错， *Windows 的原生支持最好*。我说了。

### **为什么这是 Axosoft 开发团队要解决的一个重要问题**

GitKraken 目前是 NSFW 的主要消费者。一个好的 Git 客户端不应该带有刷新按钮，因为它应该自动知道什么时候会发生变化。

What could have been: Imagine if GitKraken needed a refresh button like this. Gross!

NSFW 对于 GitKraken 流畅的跨平台体验至关重要，因为它有助于应用程序快速准确地响应它正在查看的存储库中的变化。NSFW 是一个安静、谦逊、没有虚饰的后台进程。不会兴风作浪。它不通过电影说话，不大声咀嚼，不打呼噜，但它的透明是它的长处；如果你注意到了，很可能是因为某些东西不工作了。因此，让我们为安静高效地查看文件干杯——NSFW 模块让这一切变得简单。

### **发展障碍**

哦是的。

由于对任何文件监视 API 都没有经验，对 Node (NAN) API 的本机抽象也没有什么经验，并且对如何对 Node 与每个文件监视实用程序的交互进行建模也没有清晰的理解，0.x.x NSFW 版本遇到了麻烦。

在 Windows 上，我尝试使用 C++/CLI 来使用。NET 库。虽然这使得它可以快速启动并运行，但它不可避免地适得其反，因为一些用户由于缺少库依赖而无法运行 GitKraken。*叹息*。

我还遇到了与两个不同的垃圾收集器并发运行相关的奇怪错误(一个用于节点，一个用于托管文件监视器)。当我报废了。NET 实现，我为 Windows 操作系统实现了更强的稳定性。

在 Linux 和 MacOS 上，问题围绕着不熟悉文件监视 API 和本机结构。总体上的不熟悉加上每个操作系统所采用的不同策略，最终将整个项目变成了一堆意大利面垃圾。`[REDACTED: DEEMED NSFW BY THE AXOSOFT DEPARTMENT OF PROPAGANDA]`

最后，大型文件更改操作会降低每个操作系统的速度。当时，这些消息没有节流行为。节点应用程序会受到文件系统更改通知的严重影响，速度慢得像爬行一样。在 GitKraken 中，每当我们执行引导过程时，都会遭受这样的后果，这涉及到大量的文件操作。

在 0.x.x 个月(又名*黑暗时期*)摆弄完这个项目后，我学到了很多关于每个底层文件监视器 API 如何工作的知识，包括它们的警告、要求和漏洞。

在花了一周时间拼凑了一个完整的系统图后，我把整个 0.x.x 项目都报废了，重新构建项目，有计划地处理各个操作系统的差异。我还放弃了 C++/CLI 界面，选择了 Windows 中的`ReadDirectoryChangesW`。

### **几个经验教训**

1.  预测一个系统的架构而没有先用核心特性弄脏你的手，意味着你可能最终会扔掉你的项目，用核心特性弄脏你的手，然后重新开始这个项目。作为一个新的开发者，准备好扔掉你的原型。
2.  我不确定 C++/CLI 和 Node 是否应该成为一个东西。永远不会。