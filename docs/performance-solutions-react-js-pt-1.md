# React.js 中的性能问题和解决方案:第 1 部分

> 原文：<https://www.gitkraken.com/blog/performance-solutions-react-js-pt-1>

### 这是 4 部分系列的第 1 部分！

这篇文章是关于 GitKraken 开发者所面临的性能问题的 4 篇系列文章的第一篇。这篇文章概述了问题本身，本系列的后续文章将集中讨论每个问题的解决方案是如何开发的。

## **第一部分:问题**

这听起来可能很明显，但为了改进一个应用程序，你必须找出痛点，并准确地找出导致它们的原因。

我们在 GitKraken 中注意到的一个主要问题是，存储库越大，速度越慢。我们使用了一些工具来更具体地了解这种性能下降的根源；比如电子版的 Chrome 开发工具，它包含一个分析器，可以很方便地让你知道你大部分时间都花在哪里了。

*git kraken 中某个动作的简介*

经过一些调查，很明显这个应用程序在 React 进程中花费了大量不受欢迎的时间，频繁地渲染和更新。幸运的是，React 有自己的[工具来发现性能问题](https://facebook.github.io/react/docs/perf.html)，所以我们能够转移到这个工具上来获得更细粒度的问题。结果是大部分花费的时间都在图表中，而且大部分是我们在软件开发行业中喜欢称之为*浪费的时间*。浪费的时间可能正是你所期望的——它是花费在原本不需要的过程中的时间。

在 React 的上下文中，这个过程要经历一个完整的渲染周期，包括获取新数据、更新组件、渲染和构建虚拟 DOM。最后，您将*实际的* DOM 与虚拟 DOM 进行比较，您可能会得出这两个 DOM 是相同的结论。这是浪费时间，因为不需要进行实际的 DOM 更新，而且您只是做了一堆徒劳的工作。*没什么！*

这种情况开始慢慢变成浪费时间。浪费几秒钟的时间可能*看起来*不太喜欢，但在《计算机世界》中，浪费几秒钟的时间堪比观看《T2 迷失》第五季:这看起来似乎是有意义的，你已经走了这么远，所以你需要看到它完成，但实际上这需要耗费大量的时间，变得越来越令人恼火，并最终成为真正糟糕的用户体验。

呀呀。

不管怎样…重点是，在这个时候，GitKraken 的每个动作都会导致图形渲染。这是每个动作的*，即使没有 refs 改变(例如，如果一个新的 PR 通过，或者图表上的一个时间线被更新)，整个图表刷新仍然会被执行。随后频繁的存储库刷新，以及图形渲染过程本身的缓慢，让整个应用程序感觉很慢。*

### **尝试解决方案#1:卸载图形**

我们试图通过在加载时卸载图形来解决这个问题。因此，在这个过程中，整个图形组件将从 React 中删除。这增加了存储库的加载速度，但结果是，这种方法的特殊应用数量会使应用程序代码更加复杂，长期可持续性更差。

### **尝试解决方案#2: Flux 实现和 Immutable.js**

在我们当时的 Flux 实现中，每个域都有一个存储，当一个域被更新时，这个更新会导致图形的刷新。但是，如果你有一个大的刷新，有多个域更新，你会得到一个级联效果的图形刷新计算每一个域更新。在实际的用例环境中，刷新一个存储库实际上会导致大约 8 个图形重新呈现器，对应用程序产生显著的性能影响。

为什么关于 Flux 如何运作的一个快速背景:有一个数据调度，这个调度从一个商店到另一个商店，在它前进的过程中更新东西。如果数据发生变化，每个存储都会发出一个事件，表明某些数据已经发生变化。React 然后响应这个事件，从存储中获取新数据并执行一个呈现过程。

这一切都很好，但这里的问题是，在渲染过程完全解决之前，没有后续的存储会更新。因此，对于更新多个存储的单个数据调度，这种连锁效应的成本会很高。这是我们实现 Flux 的一个基本瓶颈。

渲染过程本身加剧了这种性能损失。当你从商店中抓取新数据时，商店会给你一个数据的*深层副本*，而不是它的*实际*原始数据，以保护原始数据免受任何可能由天真编写的 React 组件引起的突变。我们已经为我们的罪过忏悔，现在跟随*一条真正的道路*。

这种深度复制被证明是昂贵的。当一个组件获得该数据副本时，它将在该数据(从存储中复制的)和它已经拥有的数据之间执行深度比较，以确定是否需要更新。

尽管在计算出是否需要执行更新这一点上有点节省时间，但这种检查本身是非常昂贵的。然而，这种深度比较实际上比仅仅更新要快。所有的行(图中的一个提交被认为是一行)，每一行都由多个组件和子组件组成，导致对它们的数据相同的多次验证。更快，但仍然是一个昂贵的事件链。

因此，我们决定引入一个名为 [Immutable.js](https://facebook.github.io/immutable-js/) 的库，它制作了不可变数组和对象，允许我们快速比较对象的一部分是否发生了变化，因为我们可以进行快速内存地址比较来查看的*是否发生了变化。虽然这很有帮助，但是如果不破坏“很多东西”就硬塞进我们现有的基础设施中，那是非常笨拙的，而且(你猜对了！)更新对象真的很慢。即使在使用内置方法批量更新时也是如此。这使得我们对数据的更新实际上比渲染花费了*更长的时间*，所以我们不得不放弃使用不可变作为解决方案。Womp womp。*

### **尝试解决方案#3 ( *奖励失败*):纯脚本**

我们尝试将很多东西迁移到 PureScript。然而，一旦我们开始，我们很快意识到这不适合我们的团队。

因此，到目前为止，我们已经确定了 3 个棘手的领域，这些领域导致了我们需要解决的性能问题:

1.  我们如何用新数据修改应用程序的状态。
2.  从存储中检索数据。
3.  确定如何以尽可能快速有效的方式更新 UI 中的组件。

这是主要的三点，每一点都需要我们重新思考如何构建应用程序。

这篇博文系列的下三部分将分别关注这些问题，我们实现的解决方案，以及我们如何实现它们。